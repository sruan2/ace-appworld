## STRATEGIES AND HARD RULES
[shr-00001] Make sure to end code blocks with ``` followed by a newline(\n).
[shr-00005] Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.
[shr-00006] Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making any irreversible change.

[shr-00009] When syncing contacts across different platforms, always collect and compare multiple identifier types (email addresses and phone numbers) as different systems may use different primary identifiers for matching users.
[shr-00016] When removing multiple items from a sequential list/queue, always remove from the end first to avoid position shifting affecting subsequent operations. This is critical for queue manipulation tasks where indices change after each removal.
[shr-00022] For media player navigation tasks (previous/next song operations), always implement a maximum attempts limit to prevent infinite loops. This ensures the system doesn't get stuck indefinitely when the desired condition (e.g., finding a liked song) might not be reachable within the current queue.
[shr-00028] For file system reorganization tasks: be precise about which directories need to be created and verify the final structure matches expectations. Only create the specific directories required by the target structure, not intermediate or temporary directories.
[shr-00031] For file system reorganization: when moving files to new directory structures, check if target directories already exist before creating them. File move operations often automatically create parent directories, so only explicitly create directories that are part of the final target structure to avoid creating unnecessary intermediate directories.
[shr-00037] When processing files with formatted data (like song titles with artists), always extract and normalize the key identifiers to match the target system's format. For example, extract just the song title portion before ' by ' when comparing against Spotify's song-only titles.
[shr-00040] When processing file data with artist-song format (e.g., 'Song Title by Artist'), always extract just the song title portion before comparison. For Spotify operations, extract text before ' by ' to match Spotify's song-only title format, as file systems may store songs with artist names while Spotify stores only titles.
[shr-00046] For Spotify queue reset tasks: follow this sequence - (1) collect all recommended songs with pagination, (2) clear current queue, (3) add recommended songs individually, (4) shuffle queue, (5) play music. This ensures the queue contains only the recommended content in randomized order before playback starts.
[shr-00048] For Spotify queue reset tasks: after adding recommended songs and shuffling, use play_music API without parameters to continue playing the current queue rather than starting new playback. This ensures the modified queue (with recommended songs) is played instead of potentially triggering different content.
[shr-00049] For financial settlement tasks involving relationships (roommates, friends, family): always resolve identities from the authoritative Phone app contact relationships rather than making assumptions from secondary sources like Venmo friends lists. Use search_contacts with relationship filters to get accurate participant counts and identities before calculating financial splits.
[shr-00052] For financial settlement tasks with equal sharing, always include yourself in the participant count when calculating splits. Expenses meant to be 'shared equally among all' include the person making the calculation, so divide the total by the total number of people (including yourself) to determine each person's share.
[shr-00054] For financial settlement tasks: when you paid for an expense and need to collect money from others, use payment requests. When someone else paid and you need to reimburse them, use direct transactions. Always include descriptive notes specifying the expense type (e.g., 'Commute', 'Dinner') for clear record-keeping.
[shr-00056] For content manipulation tasks in notes or documents, use precise line-by-line parsing rather than global string replacement when dealing with structured content. This ensures accurate updates to specific lines without affecting unrelated content that might contain similar patterns.
[shr-00064] When matching content across different systems (e.g., Simple Note to Spotify), implement robust error handling for cases where items might not be found. Include fallback strategies such as: (1) Trying alternative search queries if initial search fails, (2) Logging unmatched items for manual review, (3) Providing clear indicators in the output for items that couldn't be matched.
[shr-00065] For habit tracking and other structured note formats with consistent patterns, targeted string replacement can be more efficient than line-by-line parsing when modifying specific values. Use string replacement when: (1) The content has consistent, unique patterns for each field, (2) You need to modify only specific values while preserving the overall structure, and (3) The modification targets are unlikely to appear in other parts of the content.
[shr-00067] For habit tracking note creation: when creating a new daily entry based on a previous day's template, use targeted string replacement to update specific habit values while preserving the overall structure. This approach is efficient when the note format is consistent and only specific values need modification.
[shr-00070] For file-to-note import tasks: always extract the basename for titles, replace underscores with spaces, remove file extensions, and use file_data['content'] to get the actual content. This ensures proper title formatting and content extraction when importing files from file systems to note applications.
[shr-00071] For friend synchronization tasks across platforms: follow this sequence - (1) Identify relationships from authoritative source (Phone app contacts), (2) Retrieve current friends from target platform with proper pagination, (3) Compare using multiple identifiers (email/phone), (4) Add missing friends using appropriate API, (5) Verify operations by checking results afterward. This ensures complete and accurate friend synchronization.
[shr-00072] For paginated API calls, always use the maximum available page_limit parameter (when specified in API documentation) combined with while True loops to ensure complete data collection. Never rely on default page limits as they may return incomplete results, leading to incorrect conclusions in comparison operations.
[shr-00073] For financial operations involving dynamic state (payment requests, balances): always check current status immediately before each operation, verify available funds/limits first, and implement incremental processing with real-time verification to handle state changes that may occur during execution.
[shr-00078] For financial operations with limited funds: always check payment card limits and available balances using show_payment_card API before attempting transfers, implement systematic fund addition strategies starting with smaller test amounts, and prioritize approval of requests based on amount or urgency when complete approval isn't possible due to financial constraints.
[shr-00080] For financial operations involving date filtering (e.g., 'this calendar month'), always calculate the current month and year dynamically using datetime.datetime.now() to ensure accurate filtering across different execution times. Never hardcode month/year values.
[shr-00082] For file deletion tasks: always list files first to identify targets, use proper filtering (like file extension matching), implement error handling for individual file operations, and verify completion by checking the directory state afterward to ensure all targeted files were successfully removed.
[shr-00083] For collaborative playlist management tasks: always verify sender identities through authoritative contact relationships before processing their suggestions. Use apis.phone.search_contacts() with relationship filters to confirm roommates/friends before implementing their requested changes to shared content.
[shr-00084] When processing playlist suggestions from messages: extract playlist IDs from shared URLs using pattern matching, parse add/remove commands with clear delimiters (e.g., 'add =>', 'remove =>'), and implement changes in batch operations with verification between steps to ensure all requested modifications are applied correctly.
[shr-00089] For expense note parsing tasks: when processing Simple Note expense records with 'I owe X => $Y' and 'X owes me => $Y' patterns, extract the person name and amount using string splitting on ' => $' and appropriate pattern matching. This ensures accurate identification of debt directions and amounts for financial settlement operations.
[shr-00091] For expense note parsing tasks: when processing Simple Note expense records, carefully distinguish between 'I owe X => $Y' (requires create_transaction to send money) and 'X owes me => $Y' (requires create_payment_request to request money). This distinction is critical for proper financial settlement operations and must be accurately parsed from the note content.
[shr-00093] For note-based information retrieval tasks: always authenticate properly, search for relevant notes using appropriate queries, parse structured content systematically using day-based patterns, and extract specific values using precise string parsing techniques while accounting for current date context.
[shr-00096] For date-based information retrieval from structured notes: always calculate dates dynamically using datetime, parse structured content systematically using day-based patterns, and verify the current date context to ensure accurate extraction of time-sensitive information.
[shr-00098] For structured note content with day-based patterns (like workout plans), systematically parse the content line by line to find the specific day section and extract the target value using precise pattern matching. Always verify the current context (e.g., Sunday) and extract the numerical value from the appropriate field using string splitting and conversion to integer when needed.
[shr-00099] For payment request correction tasks: when a roommate sends an incorrect payment request (e.g., forgetting about rent decreases), follow this sequence - (1) identify the roommate through Phone app contact relationships, (2) find the specific payment request using show_received_payment_requests, (3) deny the incorrect request using deny_payment_request, (4) calculate the corrected amount, (5) send the corrected amount using create_transaction with an explanatory note. This ensures proper financial reconciliation while maintaining clear communication about the correction.
[shr-00102] For financial calculations involving monetary amounts, always use rounding to 2 decimal places to avoid floating-point precision errors. Use: corrected_amount = round(original_amount * multiplier, 2) to ensure exact monetary values for transaction processing.
[shr-00104] For genre analysis tasks: always use pagination for collection APIs (show_liked_songs), then fetch detailed information (show_song) for each item to access genre data, and use dictionary counting to track category frequencies efficiently. This ensures complete data collection and accurate genre distribution analysis.
[shr-00107] For quote collection parsing in notes: when quotes are formatted with attribution on separate lines (e.g., ' - Quote text\n   by Author'), use block-based parsing by splitting on quote markers (' - ') first, then process each quote-attribution block individually. This approach is more effective than line-by-line parsing for capturing complete quote-attribution pairs in structured collections.
[shr-00109] When parsing structured content from notes or files, always examine the raw content structure first before implementing parsing logic. Print and inspect the content with line numbers to identify the actual formatting patterns used, then implement parsing based on the observed patterns rather than making assumptions about the formatting.
[shr-00111] For artist counting tasks across multiple playlists: use a set to store unique song IDs to ensure each song is counted only once regardless of how many playlists it appears in. This ensures accurate artist song counts when the same song exists in multiple playlists.
[shr-00116] For playlist creation tasks from external sources (like Simple Note): always check the current playlist contents using show_playlist() before adding songs in batch operations. Maintain a set of already-added song IDs to prevent duplicate addition errors (422 status codes) and ensure efficient processing.
[shr-00120] For checklist/counting tasks in structured notes: use pattern matching for completion markers ([x] vs [ ]) and count occurrences systematically. This approach is efficient and accurate for tasks that require counting completed items in checklist-style notes with clear completion indicators.
[shr-00123] When filtering by date ranges (especially 'this year' or current time periods), always verify the actual current date/time in the execution environment first by checking system datetime and sample data before making assumptions. Use datetime.datetime.now() to get the actual current date in the environment context, and examine sample transaction data to confirm the correct year range for filtering.
[shr-00126] For playlist creation from liked content: when creating playlists from liked songs, albums, and playlists, collect all liked items from each source using proper pagination, then create a new playlist and add all collected items. Ensure the playlist is set to public if sharing is required.
[shr-00134] For financial transaction-based friend operations: always use proper date filtering with datetime calculations, handle pagination to get complete transaction history, extract both senders and receivers while excluding yourself, and use the add_friend API with email addresses for accurate friend addition.
[shr-00136] For transaction-based friend operations: when extracting recipients from transaction history, always collect unique email addresses and exclude your own email to avoid attempting to add yourself as a friend. Use a set data structure to automatically handle uniqueness when processing transactions.
[shr-00137] For offline playback tasks: always verify both download status and total duration of content before playing. Collect all downloaded song IDs first using pagination, then check each album's songs against this set while calculating total duration to ensure sufficient content is available for the requested time period.
[shr-00140] For extended API operations with potential token expiration: always store login credentials for re-authentication and perform time-sensitive operations (like playback) immediately after login rather than after lengthy processing. This minimizes the risk of token expiration during critical operations and ensures smooth execution of multi-step tasks.
[shr-00143] For financial transactions: always check API documentation for direct payment options before attempting balance transfers. Many payment APIs support direct card payments that bypass balance limitations. Use show_payment_cards to identify available cards and create_transaction with payment_card_id for direct payments when balance is insufficient.
[shr-00147] When facing payment limitations with Venmo-linked cards (expired cards, insufficient funds), always check the supervisor app for additional payment cards that may not be currently linked to Venmo. Use the add_payment_card API to link new cards and then use them for direct transactions via the payment_card_id parameter in create_transaction.
[shr-00149] For Venmo transactions with insufficient balance: always check if create_transaction API supports direct payment from payment cards using the payment_card_id parameter before attempting to add funds to Venmo balance. This bypasses balance limitations and is more efficient than the fund addition approach.
[shr-00151] For birthday/anniversary financial tasks: follow this sequence - (1) resolve identities from Phone contacts using date matching, (2) use transaction APIs with date filtering to find historical amounts, (3) calculate new amounts precisely, (4) execute financial transactions with appropriate privacy settings, (5) complete communication components. This workflow ensures accurate recipient identification and proper execution of both financial and messaging components.
[shr-00152] For Venmo payment requests to roommates: always use create_payment_request API (not create_transaction) when requesting money owed. Include all required parameters: recipient_email from authoritative phone contacts, exact amount, descriptive note specifying the expense purpose, and private=true for privacy as requested.
[shr-00153] For payment request approval tasks: always check Venmo balance first using show_venmo_balance() before attempting to approve payment requests. If balance is insufficient, add the exact needed amount from a valid payment card using add_to_venmo_balance() with payment_card_id before proceeding with approval. This ensures successful payment processing without 'insufficient funds' errors.
[shr-00156] When searching for messages from specific contacts, always use the most specific available identifier (phone number) rather than name-based content searches. After identifying contacts through search_contacts, use their phone_number parameter in search_text_messages for precise filtering, as content-based searches may return messages mentioning the contact rather than messages from the contact.
[shr-00158] For natural language response processing tasks (like RSVP updates): implement comprehensive keyword matching that accounts for varied phrasing patterns. Search broadly for event-related terms first, then analyze message content for both explicit and implicit acceptance/declination language across all messages from each contact, not just those containing specific keywords.
[shr-00159] When parsing CSV content without external libraries: split content by newlines to get rows, split the header row by commas to get column names, then process each data row by splitting by commas and creating dictionaries using zip(headers, values) for structured access to CSV data.
[shr-00161] When working with file systems, always explore directory contents first to verify exact file names and paths before attempting file operations. Use show_directory() to list contents and identify the correct file rather than making assumptions about file naming conventions based on task descriptions.
[shr-00163] For financial operations involving date filtering (like 'yesterday evening'), always verify the actual date context of the execution environment before applying date filters. Check sample transaction data to confirm what date/time the system is actually operating in, and use datetime.datetime.now() to get the system's current date rather than making assumptions about real-world dates. This prevents incorrect filtering when the system operates in a different timezone or with a different date setting.
[shr-00164] For payment request correction tasks: always retrieve all historical requests with pagination, filter by date using datetime calculations, delete incorrect requests first, then recreate with corrected amounts while preserving all original metadata (description, privacy, recipients). Use proper rounding for monetary amounts when subtracting/adjusting values.
[shr-00166] For transaction-based friend operations: always resolve recipient identities from the authoritative Phone app contact relationships before performing friend additions/removals. Transaction data may contain outdated or incorrect email addresses, while the Phone app maintains the canonical relationship information. Use search_contacts to verify identities and get accurate contact information before adding/removing friends based on transaction history.
[shr-00168] For friend management tasks based on financial transactions: always preserve existing relationships unless explicitly instructed to remove them. Financial transactions in a single time period should be used to ADD to relationships (ensure senders/recipients are friends), not REPLACE all relationships. Only add new contacts from transactions and maintain existing friends unless the task explicitly requires purging all non-transaction relationships.
[shr-00171] When processing structured note data from search results, always filter the results to exclude unrelated content that might appear due to tag matching or broad search queries. Verify that each entry matches the expected format before including it in the final output to ensure data integrity and accuracy.
[shr-00172] For data export tasks: always retrieve credentials from supervisor, use pagination for complete data collection, validate and filter data according to expected patterns, create output in required format before saving, and verify file creation success. For habit tracking specifically: extract dates from titles, handle missing values with defaults ('no'), and sort chronologically as specified.
[shr-00174] When processing search results from note systems, always validate that each result matches the expected title pattern before including it in processing. For habit tracking logs, filter notes by titles containing specific patterns like 'Habit Tracking Log for' to exclude unrelated content that might appear due to tag matching or broad search queries.
[shr-00175] For CSV export tasks with structured data, always handle missing values by providing appropriate defaults (e.g., 'no' for unrecorded habits) to ensure complete data representation. This maintains data integrity when some entries may not have values for all columns in the target format.
[shr-00177] For tasks involving sending messages to specific relationship groups (roommates, family, friends), always use the Phone app's relationship filtering capability (relationship parameter in search_contacts) to accurately identify the target recipients rather than making assumptions about who belongs to the group.
[shr-00180] For music library tasks involving release date filtering: use string comparison on the release_date field (e.g., startswith('2021')) to filter by year. This approach works effectively when the release_date is in YYYY-MM-DD format and you need to identify content from specific years.
[shr-00181] For alarm management tasks: always retrieve all alarms with pagination to find the correct one, verify the alarm details match the criteria (weekday repetition in this case), update only the specific parameter needed (snooze_minutes), and verify the change was applied successfully by checking the updated alarm state.
[shr-00182] For playlist genre analysis tasks: always use show_playlist API to get the complete song list for each playlist rather than relying on partial song_ids data from show_playlist_library. The song_ids field may only contain a subset of songs, leading to inaccurate genre distribution analysis.
[shr-00183] When analyzing genre distributions across playlists: implement proper pagination for playlists with many songs, add error handling for songs without genre information, and implement tie-breaking logic (e.g., alphabetical order or first occurrence) for genres with equal counts to ensure consistent results.
[shr-00185] For playlist genre analysis tasks: always use pagination for playlists with many songs, add error handling for songs without genre information, and implement tie-breaking logic (e.g., alphabetical order or first occurrence) for genres with equal counts to ensure consistent results.
[shr-00187] For monthly expense tracking tasks: always use datetime for current date calculation, implement proper pagination for transaction APIs, filter transactions by date range and direction (sent/received), maintain consistent formatting in note updates, and verify changes after updating to ensure accurate financial record-keeping.
[shr-00188] When encountering expired or insufficient Venmo-linked cards, immediately check supervisor.show_payment_cards() for additional valid payment options before attempting any transactions with the problematic cards. This prevents unnecessary API calls and errors from expired or insufficient cards.
[shr-00189] When testing payment cards for fund addition, always start with small test amounts (e.g., $10) to verify card validity and available funds before attempting larger transactions. This prevents failed API calls and helps identify which cards have sufficient funds for the required operations.
[shr-00190] For habit tracking log retrieval: always search using broad title pattern matching (e.g., 'Habit Tracking Log for') rather than content-specific keywords to ensure all historical data is captured. Content-specific searches may miss older notes that don't contain the specific keyword in their content but follow the same title format.
[shr-00191] When calculating streaks from habit tracking data: (1) sort entries chronologically by date, (2) iterate through the sorted data tracking consecutive 'yes' values, (3) reset the streak counter on 'no' values, and (4) maintain the maximum streak encountered during iteration to find the longest continuous period.
[shr-00193] For financial operations involving date filtering when APIs don't support it natively: always collect all data with pagination first using while True loops, then filter locally using datetime calculations. This ensures complete data collection across all pages before applying date-based filtering logic.
[shr-00195] For account creation tasks: always verify account non-existence through multiple search methods before attempting creation, implement comprehensive error handling to capture detailed API error messages, systematically test different parameter combinations, verify preconditions (like logout state), and explore alternative approaches when primary methods fail. This ensures robust handling of account creation scenarios.
[shr-00198] For account creation tasks: always verify account non-existence through multiple search methods before attempting creation, implement comprehensive error handling to capture detailed API error messages, systematically test different parameter combinations, verify preconditions (like logout state), and explore alternative approaches when primary methods fail. This ensures robust handling of account creation scenarios.
[shr-00206] For library comparison tasks (liked vs unliked content): always collect complete datasets using pagination before performing set operations. Use while True loops with break conditions instead of fixed ranges to ensure all pages are processed. Maintain separate collections for library items and liked items, then use set operations (difference) to efficiently identify items that need action.
[shr-00209] For personal communication tasks: always resolve recipient identities through authoritative contact relationships (phone app), retrieve content from the specified source (e.g., Simple Note), and deliver exactly what was requested (e.g., just the name, nothing else) without additional formatting or commentary.
[shr-00210] For Todoist task reassignment based on comments: systematically check all comments on each incomplete task using pattern matching for volunteer phrases ('I'll take', 'I can take', 'assign to me', etc.), verify the commenter is not the current assignee, and use the exact first name from the user profile when posting thank you comments. Maintain the original task state for tasks without volunteer agreements.
[shr-00213] For financial reconciliation tasks between payment platforms (Venmo) and accounting platforms (Splitwise): always verify actual transactions exist on the payment platform before recording them on the accounting platform. Use exact amount and recipient matching, and always use actual transaction receipts as proof rather than creating placeholders. Financial systems should be reconciled based on actual transaction data, not assumptions.
[shr-00217] For financial reconciliation tasks between payment and accounting platforms: focus only on exact matches (amount and recipient) within the specified timeframes. Process only verifiable matches and accept that some transactions may be for different time periods or purposes than initially assumed. Avoid exhaustive searching for uncertain matches when clear matches exist.
[shr-00219] For message processing tasks involving invitations or codes: always verify the message content contains actual invitation patterns before processing. Check for keywords like 'invitation', 'join', 'group', 'code' along with the service name (e.g., 'Splitwise') to distinguish actual invitations from casual mentions in conversations.
[shr-00220] When extracting codes or identifiers from messages: use multiple pattern matching strategies including regex patterns for common formats (e.g., 'code => XXXX', 'invitation code: XXXX', URL parameters like '?code=XXXX'). Implement fallback parsing for different invitation formats and validate extracted codes before using them in API calls.
[shr-00224] For voice message processing tasks with invitation codes: always check the 'contact_id' field in message responses to determine if senders are in the contact book. This field provides direct verification without additional API calls, making contact status checking more efficient than searching contacts separately.
[shr-00225] When processing Splitwise invitation messages: extract invitation codes using pattern matching for 'code => XXXX' format. This specific pattern is commonly used in Splitwise invitation messages and provides the code needed for API acceptance calls.
[shr-00228] When processing text messages with invitation codes: use precise regex pattern matching (e.g., r'code =>\s*([a-zA-Z0-9]+)') to extract clean alphanumeric identifiers from message content. This ensures proper code extraction by removing trailing punctuation and capturing only the valid code portion needed for API operations.
[shr-00229] For message processing tasks involving contact verification: leverage the built-in 'contact_id' field in message responses to determine if senders are in the contact book. This provides direct verification without additional API calls, making contact status checking more efficient than searching contacts separately.
[shr-00231] For financial reconciliation tasks across different systems (Simple Note to Splitwise): always resolve naming discrepancies by creating a mapping from simplified identifiers (first names) to full system identifiers (full names with emails). Extract first names from source data, map to target system's full names using group membership data, and use the mapped identifiers for financial operations to ensure accurate expense recording.
[shr-00235] For natural language expense parsing tasks: when processing expense descriptions with 'Owed equally by' clauses containing comma-separated lists followed by 'and', implement robust parsing that handles both comma-separated items and final 'and'-separated items. Split by commas first, then check if the last item contains 'and' and split it further to extract all individual debtors accurately.
[shr-00236] For group-based financial operations: when encountering API conflicts for group creation ('group already exists') but the group doesn't appear in search results, try creating the group with a slightly modified name while preserving semantic meaning. This handles cases where groups may exist but aren't visible due to API caching or visibility limitations.
[shr-00238] For collaborative playlist management via Todoist comments: follow this sequence - (1) find the correct project and task using show_projects and show_tasks, (2) parse playlist suggestions from comments using pattern matching for 'add =>' and 'remove =>' commands, (3) extract playlist ID from shared URLs using pattern matching, (4) implement batch add/remove operations on the playlist, (5) add a completion comment, and (6) mark the task complete. This ensures all requested changes are properly implemented and tracked in the project management system.
[shr-00241] When extracting IDs from user-generated content or URLs, always implement robust parsing with multiple fallback strategies. Use chain splitting operations (e.g., split('/playlists/')[1].split('?')[0].split(' ')[0]) and handle conversion to required data types (integer) with validation. Never assume clean formatting in user content - always test parsing logic with the actual data structure observed to handle trailing punctuation, spaces, or other unexpected characters.
[shr-00243] For financial payment tasks involving CSV data: always check Venmo balance first using show_venmo_balance() before attempting transactions, and add sufficient funds using add_to_venmo_balance() with a valid payment_card_id when balance is insufficient. This prevents 'insufficient funds' errors and ensures successful payment processing.
[shr-00244] When checking if users exist on Venmo for payment processing: use exact email address matching rather than relying solely on search results. Search for users by email, then verify that at least one result has an exact email match before attempting transactions to avoid 'user does not exist' errors.
[shr-00245] For file attachment tasks with CSV data: systematically map descriptions to file names by normalizing both keys (lowercase, replace spaces with underscores) to find matching PDF receipts in the same directory. This ensures proper receipt attachment when descriptions in CSV files correspond to file names in the directory.
[shr-00249] For financial payment tasks with CSV data and receipt attachments: systematically map descriptions to file names by normalizing both keys (lowercase, replace spaces with underscores) to find matching PDF receipts in the same directory. This ensures proper receipt attachment when descriptions in CSV files correspond to file names in the directory.
[shr-00250] When processing financial payments from CSV data with multiple payment methods (Venmo/Splitwise): always check Venmo balance first using show_venmo_balance() before attempting transactions, and add sufficient funds using add_to_venmo_balance() with a valid payment_card_id when balance is insufficient. This prevents 'insufficient funds' errors and ensures successful payment processing.
[shr-00251] When checking if users exist on Venmo for payment processing: use exact email address matching rather than relying solely on search results. Search for users by email, then verify that at least one result has an exact email match before attempting transactions to avoid 'user does not exist' errors.
[shr-00252] For financial payment tasks with CSV data: always check Venmo balance first using show_venmo_balance() before attempting transactions, and add sufficient funds using add_to_venmo_balance() with a valid payment_card_id when balance is insufficient. This prevents 'insufficient funds' errors and ensures successful payment processing.
[shr-00253] For task management workflows with prioritization requirements: always check due dates and identify overdue tasks first before processing newer items. Use the API's due_date filtering capabilities (min_due_date/max_due_date parameters) to identify tasks that are past due and should be prioritized as 'left overs from current day' before moving other tasks based on available capacity.
[shr-00254] For friend synchronization across platforms: maintain separate identifier sets for emails and phone numbers when comparing contacts, but only use the identifier type required by the target API for operations (emails for Venmo). Implement matching logic that checks both identifier types separately but only operates using the required identifier type, and handle cases where required identifiers might be missing by skipping those contacts or finding alternative approaches.
[shr-00259] For media player navigation tasks: avoid using artificial delays (like time.sleep) between operations as API calls naturally provide sufficient state synchronization. The system updates state immediately after API operations, making delays unnecessary and potentially causing execution errors in restricted environments.
[shr-00261] For file reorganization tasks with patterned filenames: always parse the original filename structure systematically using the specified delimiter (e.g., '__' in '<date>__<file_name>.<extension>') to extract components for the target structure. This ensures accurate extraction of date, filename, and extension parts before creating the new directory hierarchy and moving files.
[shr-00263] For Venmo transaction analysis tasks: when calculating sent vs received amounts, always compare the transaction sender/receiver email addresses against your own email address to accurately determine transaction direction. This ensures proper categorization of whether money was sent to others (you are sender) or received from others (you are receiver).
[shr-00266] For multi-playlist archiving operations: always check target playlist contents before adding songs to avoid duplicate addition errors (422 status). Maintain a set of already-added song IDs and verify each song is not already present in the target playlist before attempting addition operations, especially when the same song might exist in multiple source playlists.
[shr-00267] For multi-playlist archiving operations: always check target playlist contents before adding songs to avoid duplicate addition errors (422 status). Maintain a set of already-added song IDs and verify each song is not already present in the target playlist before attempting addition operations, especially when the same song might exist in multiple source playlists.
[shr-00269] When searching for content across different systems (like song titles from notes to Spotify), always implement proper pagination with while True loops to collect all potential matches, then select the best match based on comprehensive comparison of title, artist, and other metadata. This ensures accuracy when content might have multiple versions or similar titles that could appear on different search result pages.
[shr-00270] For date conversion tasks between different systems: when converting from ISO format (YYYY-MM-DD) to MM/YYYY format, use string slicing operations: month_year = f"{release_date[5:7]}/{release_date[0:4]}" to extract the month and year components accurately. This ensures proper formatting when systems use different date representation standards.
[shr-00273] For note update tasks involving external data enrichment (like adding release dates from Spotify to Simple Note): follow this sequence - (1) authenticate with both systems, (2) parse structured note content to identify items needing data, (3) use proper pagination when searching external APIs, (4) convert data formats as needed (e.g., ISO dates to MM/YYYY using string slicing), (5) update note content systematically, and (6) verify changes before task completion. This ensures complete and accurate data synchronization between systems.
[shr-00277] For payment request approval tasks: always check Venmo balance first using show_venmo_balance() before attempting approvals. If balance is insufficient, calculate the total amount needed for pending requests and add sufficient funds from a valid payment card using add_to_venmo_balance() with payment_card_id before proceeding with approval operations. This ensures successful payment processing without 'insufficient funds' errors.
[shr-00278] For financial payment approval tasks: always follow this optimal sequence - (1) Verify financial requirements by calculating total amount needed, (2) Check available Venmo balance using show_venmo_balance(), (3) Verify payment card availability and limits using show_payment_cards, (4) Add sufficient funds using add_to_venmo_balance() with valid payment_card_id, (5) Execute all approval operations in batch. This prevents unnecessary API failures and optimizes the approval process by handling financial verification upfront.
[shr-00279] For payment request approval tasks: always resolve identities from authoritative sources (Phone contacts), implement complete pagination for data collection, verify current financial state before operations, handle insufficient funds by adding from valid payment cards, and process approvals systematically after all preconditions are met. Use datetime calculations for accurate month filtering rather than hardcoded values.
[shr-00281] When searching for structured content in messages (like playlist modification requests), use the specific command patterns (e.g., 'add =>', 'remove =>') as search terms rather than general topic keywords. This ensures precise retrieval of the relevant messages containing the actual modification instructions and avoids filtering through irrelevant conversation content.
[shr-00285] For batch financial transaction processing: always maintain a complete record of all original transaction details (amount, recipient, type) alongside API results to ensure accurate verification and reporting. Either store all relevant information needed for summary/verification in the results data structure, or maintain easy access to the original source data for reference during final reporting stages.
[shr-00287] For quote extraction tasks from structured collections: use line-by-line parsing with pattern matching for quote markers (e.g., '- '), split on attribution markers ('by') to isolate quote text from attribution, and use random.choice() for random selection when returning a single random quote from the collection.
[shr-00288] For quote extraction tasks from structured collections: always immediately examine the raw content structure with line-by-line printing before implementing parsing logic. This ensures accurate identification of the actual formatting patterns (e.g., lines starting with ' - ') rather than making assumptions that may lead to empty results or parsing errors.
[shr-00289] For quote extraction tasks: when parsing content with dash-prefixed quotes, always verify the exact formatting pattern by examining raw content first. Quotes may use single dash format ('- Quote text') instead of the more common dash-space format (' - Quote text'). Implement parsing logic that matches the observed pattern rather than making assumptions about the prefix format.
[shr-00290] For artist counting tasks across multiple playlists: collect all unique song IDs using a set to ensure each song is counted only once regardless of playlist appearances, then retrieve detailed song information to extract all contributing artists from the 'artists' array, and maintain a dictionary to count songs per artist before identifying those with the minimum counts. This ensures accurate artist song counts when the same song exists in multiple playlists and songs may have multiple contributing artists.
[shr-00291] For Simple Note to Spotify playlist creation tasks: follow this sequence - (1) Search Simple Note with specific queries like 'Spotify Playlist Songs' to find the target note, (2) Parse song entries using ' by ' as the separator between title and artist, (3) Search Spotify using just the song title portion (before ' by ') for better matching, (4) Create the playlist with the specified title, (5) Add all found songs, and (6) Verify the final playlist contains the expected number of songs. This ensures accurate cross-platform content transfer from note-based song lists to Spotify playlists.
[shr-00293] For Simple Note to Spotify playlist creation tasks: follow this sequence - (1) Search Simple Note with specific queries to find the target note, (2) Parse song entries using ' by ' as the separator between title and artist, (3) Search Spotify using just the song title portion (before ' by ') for better matching, (4) Create the playlist with the specified title, (5) Add all found songs, and (6) Verify the final playlist contains the expected number of songs. This ensures accurate cross-platform content transfer from note-based song lists to Spotify playlists.
[shr-00295] For financial transaction analysis with specific expense categories (like 'internet bills'): always combine date filtering (min_created_at/max_created_at) with query parameter filtering to search for specific keywords in transaction descriptions. This ensures accurate categorization of expenses by purpose when calculating totals for specific bill types or expense categories.
[shr-00296] For playlist creation from multiple liked sources: collect all liked songs, albums, and playlists using proper pagination, use a set to deduplicate song IDs across sources, create the playlist before adding songs, and use the shareable_link field from show_playlist API for sharing URLs rather than constructing URLs manually.
[shr-00299] For playlist sharing tasks: always use the API-provided shareable_link field from show_playlist() rather than constructing URLs manually. Create playlists as public from the start using the 'public' parameter in create_playlist, and verify the shareable_link field is populated before sharing. If shareable_link is initially null after making a playlist public, wait briefly and retry the show_playlist call as it may take time to generate.
[shr-00306] For transaction-based friend operations: follow this sequence - (1) Extract email addresses from transaction history with proper date filtering and pagination, (2) Verify each email address through the authoritative Phone app contact relationships using search_contacts, (3) Only add friends for contacts that exist in the Phone app with matching email addresses, (4) Use the verified contact information from the Phone app for friend operations rather than transaction email addresses directly. This ensures friend operations are performed on verified identities rather than potentially stale transaction data.
[shr-00307] For transaction-based friend operations: always resolve recipient identities from the authoritative Phone app contact relationships before performing friend additions/removals. Transaction data may contain outdated or incorrect email addresses, while the Phone app maintains the canonical relationship information. Use search_contacts to verify identities and get accurate contact information before adding/removing friends based on transaction history.
[shr-00311] For financial transactions with payment cards: always check card expiration dates using expiry_year and expiry_month fields before attempting transactions. Only use cards with future expiration dates (expiry_year > current_year OR (expiry_year == current_year AND expiry_month >= current_month)) to avoid transaction failures from expired payment methods.
[shr-00312] When facing financial constraints with payment methods: implement a systematic fund addition strategy starting with small test amounts (e.g., $10) to verify card validity and available funds before attempting larger transactions. This helps identify which payment methods have sufficient funds and prevents failed API calls.
[shr-00314] For financial transactions with potential balance limitations: always implement a systematic fund verification strategy by (1) checking Venmo balance first, (2) testing payment cards with small amounts ($10) to verify functionality before attempting larger transactions, and (3) using direct payment options (payment_card_id parameter) when available to bypass balance constraints, as this is often more efficient than adding funds to Venmo balance first.
[shr-00315] When facing multiple payment card options with unknown fund availability: always start with small test amounts ($10) to identify which cards have sufficient funds before attempting the full transaction amount. This prevents failed API calls and helps systematically identify working payment methods without assuming card capabilities based on expiration dates alone.
[shr-00317] For payment request approval tasks: always calculate the exact amount needed by subtracting current Venmo balance from the request amount before adding funds. Use: amount_needed = max(0, request_amount - current_balance) to determine the precise amount to add from payment cards, avoiding unnecessary fund additions and ensuring optimal financial management.
[shr-00318] For payment card validation: always check card expiration dates against the current system date using datetime.datetime.now(). A card is valid if expiry_year > current_year OR (expiry_year == current_year AND expiry_month >= current_month). This ensures only valid payment methods are used for financial operations and prevents transaction failures from expired cards.
[shr-00321] For RSVP update tasks: follow this sequence - (1) access the target file system location to find the tracking CSV, (2) search message history with comprehensive query terms to capture all response patterns (yes, no, can't make it, etc.), (3) systematically update the data structure while preserving the original CSV format, and (4) verify changes before task completion. This ensures accurate tracking of response statuses across communication channels.
[shr-00322] When processing natural language RSVP responses from messages: implement comprehensive keyword matching that accounts for varied phrasing patterns (e.g., 'yes, I'll be there', 'can't make it', 'sorry, can't join'). Search for both positive and negative response indicators across all messages to ensure complete capture of RSVP status updates.
[shr-00324] For RSVP update tasks: always resolve friend identities through authoritative phone contacts before processing messages, implement comprehensive date filtering to ensure only recent responses are considered, analyze complete conversation histories rather than individual messages to determine the most current response, and verify message context matches the specific event before updating RSVP statuses. This prevents incorrect updates from irrelevant historical messages or conversations about different events.
[shr-00326] For 'yesterday evening' time filtering: when calculating date ranges for specific time periods like 'yesterday evening', use datetime.timedelta(days=1) to get yesterday's date, then set specific hour ranges (e.g., 18:00 to 23:59) to define the 'evening' period precisely. This ensures accurate filtering for time-sensitive operations like payment request corrections.
[shr-00327] For payment request correction tasks with time-based filtering: when calculating 'yesterday evening' time periods, use datetime.timedelta(days=1) to get yesterday's date, then set specific hour ranges (e.g., 18:00 to 23:59) to define the 'evening' period precisely. This ensures accurate filtering for time-sensitive operations like payment request corrections where requests need to be identified within specific time windows.
[shr-00329] For 'yesterday evening' time filtering: when calculating date ranges for specific time periods like 'yesterday evening', use datetime.timedelta(days=1) to get yesterday's date, then set specific hour ranges (e.g., 18:00 to 23:59) to define the 'evening' period precisely. This ensures accurate filtering for time-sensitive operations like payment request corrections where requests need to be identified within specific time windows.
[shr-00330] For transaction-based friend operations: when managing relationships based on financial transactions, use transactions to ADD new relationships but only remove relationships for those explicitly not in the transaction set. Never interpret single-period transaction data as a complete replacement for all existing relationships unless the task explicitly instructs complete replacement. The correct logic is: friends_to_add = transaction_emails - current_friend_emails (add new transaction partners) and friends_to_remove = current_friend_emails - transaction_emails (only remove non-transaction friends), while preserving current_friend_emails  transaction_emails (existing friends who transacted).
[shr-00331] For transaction-based friend operations: use proper set operations to correctly identify only NEW people to add (transaction_emails - current_friend_emails) and only OLD friends to remove (current_friend_emails - transaction_emails), while preserving existing relationships that match the transaction criteria (current_friend_emails  transaction_emails). Always verify user existence before attempting friend operations to avoid 'user not found' errors.
[shr-00332] For transaction-based friend operations: when the task explicitly instructs to 'befriend transaction senders and unfriend everyone else', implement this logic strictly regardless of whether transaction senders overlap with current friends. The instruction implies complete replacement of the friend list based on transaction activity, not additive friend management. Use set operations: friends_to_add = transaction_emails (all senders) and friends_to_remove = current_friend_emails - transaction_emails (all non-senders), even if this results in complete friend list replacement.
[shr-00334] For habit tracking CSV export tasks: when creating the header row, maintain the exact order of habits as they appear in the original logs rather than sorting alphabetically. This ensures the exported CSV matches the user's expected column order and maintains consistency with their tracking system.
[shr-00336] For music library tasks involving release date filtering: always verify the actual date format from sample data before implementing filtering logic. The release_date field in Spotify's show_song API typically uses 'YYYY-MM-DDTHH:MM:SS' format, so use string comparison (e.g., startswith('2020')) to filter by year accurately.
[shr-00337] For batch update tasks across multiple items (like playlist genre analysis): follow this sequence - (1) authenticate with the target system, (2) collect all target items using proper pagination, (3) process each item systematically to gather required data, (4) implement updates in batch operations, and (5) verify all changes were applied correctly. This ensures complete processing and accurate results for tasks that require analyzing and modifying multiple entities.
[shr-00338] For playlist genre analysis tasks: when multiple genres have the same count (ties), implement consistent tie-breaking logic such as selecting the genre that appears first alphabetically or the first genre encountered with the maximum count. This ensures deterministic results when the most common genre is not unique within a playlist.
[shr-00339] For monthly expense tracking tasks: always use datetime for current date calculation, implement proper pagination for transaction APIs, filter transactions by date range and direction (sent/received), maintain consistent formatting in note updates, and verify changes after updating to ensure accurate financial record-keeping.
[shr-00340] When parsing structured content from notes or files, always examine the raw content structure first before implementing parsing logic. Print and inspect the content with line numbers to identify the actual formatting patterns used, then implement parsing based on the observed patterns rather than making assumptions about the formatting.
[shr-00342] For financial transactions with potential balance limitations: always check if the transaction API supports direct payment options (payment_card_id parameter) before attempting to add funds to the platform balance. Direct payment from cards is often more efficient and can bypass balance constraints when cards have sufficient funds, eliminating the need for balance transfer operations.
[shr-00343] For financial operations with potential balance limitations: always implement a systematic fund verification strategy by (1) checking Venmo balance first, (2) testing payment cards with small amounts ($10) to verify functionality before attempting larger transactions, and (3) using the available balance to complete as much of the task as possible when full completion isn't feasible due to financial constraints.
[shr-00344] For habit tracking log retrieval from paginated APIs: always implement proper pagination using while True loops with page_index parameter to ensure all historical data is captured. The search_notes API may return results across multiple pages, so continue fetching until an empty page is returned to get complete historical habit tracking data for accurate streak calculations.
[shr-00346] When processing habit tracking logs from search results, always filter notes by titles containing specific patterns like 'Habit Log --' to exclude unrelated content that might appear due to broad search queries. This prevents IndexErrors when trying to extract date information from titles and ensures only relevant habit tracking data is processed.
[shr-00347] For payment request analysis with date filtering: when APIs don't support native date filtering parameters (like show_received_payment_requests), always collect all data with pagination first using while True loops, then filter locally using datetime calculations. This ensures complete data collection across all pages before applying date-based filtering logic for accurate financial calculations.
[shr-00348] For payment request analysis with date filtering: when APIs don't support native date filtering parameters (like show_received_payment_requests), always collect all data with pagination first using while True loops, then filter locally using datetime calculations. This ensures complete data collection across all pages before applying date-based filtering logic for accurate financial calculations.
[shr-00350] For account creation tasks: always verify account non-existence through multiple search methods before attempting creation, implement comprehensive error handling to capture detailed API error messages, systematically test different parameter combinations, verify preconditions (like logout state), and explore alternative approaches when primary methods fail. This ensures robust handling of account creation scenarios.
[shr-00353] For account creation tasks with persistent API failures: when facing consistent API errors despite proper parameter usage and authentication handling, implement comprehensive error handling to capture detailed response messages, explore alternative approaches systematically, and complete whatever portions of the task are actually achievable within system constraints while providing clear documentation of API limitations in the execution results.
[shr-00357] For library comparison and bulk operation tasks: always use proper pagination with while True loops to collect complete datasets, use set operations (difference) to efficiently identify items needing action, and implement verification steps to confirm successful completion. This ensures all target items are processed without missing any due to pagination limits and provides confirmation that the bulk operations were executed correctly.
[shr-00358] For personal communication tasks: always resolve recipient identities through authoritative contact relationships (phone app), retrieve content from the specified source (e.g., Simple Note), and deliver exactly what was requested (e.g., just the name, nothing else) without additional formatting or commentary. This ensures precise execution of communication tasks where only specific information is needed.
## APIs TO USE FOR SPECIFIC INFORMATION
[api-00004] You can use the "supervisor" app to get information about my accounts and use the "phone" app to get information about friends and family.

[api-00018] For Spotify queue operations: use play_music API without parameters to continue playing the current queue after modifications. This ensures the player resumes with the remaining queue content rather than starting a new playback session.
[api-00019] For Spotify queue operations after modifications: use play_music API without parameters to continue playing the current queue. This ensures the player resumes with the remaining queue content rather than starting a new playback session with potentially different content.
[api-00020] For Spotify queue manipulation: show_song_queue returns songs with position (0-indexed) and song_id fields. remove_song_from_queue requires position parameter (integer) and removes by queue position, not song_id. Always use song_id comparison to identify songs to remove, then track their positions for removal.
[api-00023] For Spotify download status checking: show_downloaded_songs returns paginated results with song_id fields. Always collect all downloaded song IDs first using pagination, then use song_id comparison to check if current/next songs are downloaded, rather than checking download status individually for each song.
[api-00025] For Spotify liked song navigation: use show_liked_songs with pagination to collect all liked song IDs first, then navigate through the queue using next_song API while comparing current song IDs against the pre-fetched liked songs set. This is more efficient than checking like status for each song individually during navigation.
[api-00027] For file system operations: directory_exists API requires 'directory_path' parameter (string), create_directory requires 'directory_path' parameter (string), and move_file requires 'source_file_path' and 'destination_file_path' parameters (strings). Always check API documentation for exact parameter names before calling.
[api-00034] For Venmo transaction queries: use show_transactions API with direction='sent' or 'received' to filter transaction direction, and min_created_at/max_created_at parameters with YYYY-MM-DD format for date filtering. Always handle pagination to collect all transactions across pages when calculating totals.
[api-00035] For financial transaction queries (Venmo, banking, etc.): always use proper date filtering (YYYY-MM-DD format), handle pagination with while True loops, filter by transaction direction ('sent'/'received'), and sum amounts across all pages to get accurate totals. This ensures complete data collection and accurate financial calculations.
[api-00036] For Venmo transaction queries asking for 'sent to or received from': always provide both sent and received amounts separately in the answer, not just the net flow. The task requires showing both transaction directions individually rather than a combined total.
[api-00045] For Spotify recommendations: show_recommendations API returns paginated results with song_id, title, and artist information. Always use pagination (while True loop over page_index) to collect all recommended songs before queue operations, as recommendations may span multiple pages.
[api-00053] For Venmo financial settlements: use create_payment_request API when requesting money from others (money owed to you), and use create_transaction API when sending money to others (money you owe them). This distinction is critical for proper financial settlement workflows.
[api-00057] For music-related information retrieval: use Spotify's search_songs API with appropriate query parameters to find release date information. The API returns release_date in YYYY-MM-DD format which can be converted to MM/YYYY format for display purposes in notes or other applications.
[api-00062] For Spotify song search operations: always implement proper pagination using while True loops over page_index when using search_songs API, as relevant results may span multiple pages. The default page_limit is 5, so important matches could be missed without proper pagination handling.
[api-00069] For file system operations: show_file API returns a dictionary with metadata including 'content' field containing the actual file content as a string, not just the raw file content. Always extract file_data['content'] when reading files to get the actual content for processing or transfer operations.
[api-00076] For Venmo payment request approval: use show_venmo_balance API to check available funds before attempting approvals, and add_to_venmo_balance with payment_card_id parameter to add funds from payment cards when balance is insufficient for requested operations.
[api-00077] For Venmo payment operations: use show_payment_card API to check individual card limits and available funds before attempting balance additions. This prevents failed API calls and allows for systematic fund management strategy implementation.
[api-00081] For Venmo payment request approval tasks: when insufficient funds are available, use show_payment_cards API to list available payment cards, then use add_to_venmo_balance with a valid payment_card_id to add the required amount before proceeding with approval operations.
[api-00085] For playlist URL parsing: shared Spotify playlist URLs follow the pattern 'https://spotify.com/playlists/<playlist_id>'. Extract the numeric playlist_id from the URL to use with playlist management APIs like show_playlist, add_song_to_playlist, and remove_song_from_playlist.
[api-00087] For Spotify playlist operations: remove_song_from_playlist requires song_id parameter (integer) to remove by song identifier, not position. This differs from queue operations where remove_song_from_queue uses position parameter. Always check API documentation to confirm the correct parameter type for removal operations.
[api-00088] For 'most followed artist' tasks: use show_following_artists API with pagination to collect all followed artists, then find the maximum follower_count. The API returns follower_count directly for each artist, eliminating the need for additional show_artist API calls to get follower information.
[api-00094] For workout plan retrieval from Simple Note: use search_notes with 'workout' or 'exercise' queries to find relevant notes, then parse the structured content using day-based patterns to extract duration information for the current day.
[api-00100] For Venmo payment request management: use show_received_payment_requests to find pending requests from specific senders, deny_payment_request to reject incorrect requests, and create_transaction to send corrected amounts with explanatory notes. This workflow is essential for handling billing errors and ensuring accurate financial settlements with roommates and friends.
[api-00106] For Spotify 'liked songs' analysis: use show_liked_songs API with pagination to get all explicitly liked songs, then use show_song for each liked song to access genre data. This ensures accurate analysis of songs the user has specifically marked as liked rather than songs that happen to be in playlists.
[api-00112] For Spotify artist information: show_song API returns artist data in an 'artists' array containing objects with 'id' and 'name' fields, not a single 'artist' field. Always iterate through the artists array to extract all contributing artists for each song when counting or analyzing artist contributions.
[api-00121] For bucket list or checklist completion counting: use SimpleNote's search_notes API with relevant queries ('bucket list', 'checklist') to find target notes, then use show_note API to retrieve content, and parse for completion markers ([x]) using string pattern matching to count completed items.
[api-00127] For Spotify playlist sharing: use show_playlist API to retrieve the shareable_link field after creating a playlist. This provides the URL needed for sharing playlists with others via text messages or other communication methods.
[api-00132] For Venmo balance checking: show_venmo_balance API returns {'venmo_balance': number} not {'balance': number}. Always check API documentation for exact response field names to avoid KeyError exceptions when accessing balance information.
[api-00133] For Venmo payment card identification by last four digits: use show_payment_cards API to get all cards, then convert card_number to string and check if it ends with the target digits. The API returns full card numbers as integers, not separate last_four_digits fields, so use: str(int(card['card_number'])).endswith('4184') to identify the correct card.
[api-00135] For Venmo friend operations based on transaction history: use show_transactions API with date filtering (min_created_at/max_created_at in YYYY-MM-DD format) to get all transactions, then extract unique contacts from both sender and receiver fields while excluding your own email, and use add_friend API with email addresses to add contacts.
[api-00138] For Spotify album duration checking: show_album API does not return song durations. Use show_song API for each song to get duration information when calculating total playback time for albums or playlists.
[api-00144] For Venmo direct payments: use create_transaction API with payment_card_id parameter to send money directly from payment cards without requiring sufficient Venmo balance. This bypasses balance limitations and allows transactions even when Venmo balance is zero.
[api-00148] For discovering additional payment options: use supervisor.show_payment_cards() to identify payment cards that may not be currently linked to your Venmo account, then use venmo.add_payment_card() to link them before using them for transactions.
[api-00150] For Venmo transaction operations: show_transactions API uses 'user_email' parameter to filter transactions by user, while create_transaction API uses 'receiver_email' parameter to specify the recipient. Always check API documentation for each specific API call to ensure correct parameter naming, even within the same app.
[api-00178] For sending voice messages to contacts: use send_voice_message API with phone_number parameter (from contact search) and message parameter containing the text to be converted to voice. The API returns confirmation with voice_message_id upon successful delivery.
[api-00179] For Spotify API authentication: every Spotify API call requires explicit passing of the access_token parameter obtained from login, even for playback operations. Never assume authentication state persists across API calls - always include access_token=spotify_access_token in every Spotify API call to avoid 401 unauthorized errors.
[api-00186] For playlist genre analysis tasks: use show_playlist API to get song lists, then show_song API for each song to access genre information. The show_song API returns a 'genre' field that contains the genre classification needed for determining the most common genre in a playlist.
[api-00194] For Venmo payment request queries: use show_received_payment_requests API with pagination to collect all requests, then filter by date range locally since the API doesn't support native date filtering parameters. This approach ensures complete data collection for accurate financial calculations.
[api-00203] For tracking Venmo friend additions over time: use the search_friends API with pagination and filter by the friends_since field to identify friendships established within specific date ranges. This field provides the exact timestamp when each friendship was established and is the most reliable method for counting friends added during specific time periods.
[api-00204] For Venmo friend tracking over time: use search_friends API with pagination and filter by the friends_since field to identify friendships established within specific date ranges. The API returns friends_since in ISO format (e.g., '2019-01-01T00:00:00') which can be directly compared with other ISO format date strings for chronological filtering.
[api-00207] For Spotify library comparison tasks: use show_song_library and show_album_library to get all content in your library, then compare against show_liked_songs and show_liked_albums to identify unliked items. All these APIs support pagination and should be processed with while True loops to ensure complete data collection before comparison.
[api-00211] For Todoist task management: use show_tasks with assignee_email and is_completed filters to find assigned incomplete tasks, show_task_comments to check for volunteer agreements, assign_or_unassign_task to reassign tasks, and post_task_comment to leave thank you messages. Always handle pagination for comments when checking task discussions.
[api-00214] For Venmo receipt retrieval: use download_transaction_receipt API to get actual transaction receipts as proof for Splitwise payment recording. This ensures proper documentation of financial transactions between platforms rather than using placeholder receipts.
[api-00226] For Splitwise group invitation acceptance: use accept_group_invitation API with the invitation_code parameter extracted from message content. The API requires the exact code format found in invitation messages (typically following 'code =>' pattern).
[api-00239] For Todoist-based collaborative playlist management: use show_projects to find the target project, show_tasks to locate the playlist task, show_task_comments to parse suggestions, then use Spotify's playlist management APIs (show_playlist, add_song_to_playlist, remove_song_from_playlist) to implement changes, and finally post_task_comment and update_task to complete the Todoist workflow.
[api-00246] For Venmo user existence checking: use search_users API with email query, then verify exact email matching in the results before attempting create_transaction. This ensures users actually exist on the platform before payment attempts.
[api-00258] For Spotify queue removal operations: when removing multiple songs by position, always remove from the highest position to the lowest position in a single pass without re-fetching the queue between operations. This ensures that each removal doesn't affect the positions of songs that will be removed next, as position numbers decrease for all subsequent songs after each removal.
[api-00265] For Spotify artist information extraction: when processing song data from show_song API, always extract artist names from the 'artists' array using list comprehension: [artist['name'] for artist in song_info['artists']]. The API returns an array of artist objects with 'id' and 'name' fields, not a single 'artist' string field.
[api-00271] For music release date information: use Spotify's show_song API which returns release_date in ISO format (YYYY-MM-DDTHH:MM:SS). Extract the month and year components using string slicing (positions 5-7 for month, 0-4 for year) to convert to MM/YYYY format for display in notes or other applications.
[api-00276] For contact relationship filtering: use the Phone app's search_contacts API with the relationship parameter to filter contacts by specific relationship types (e.g., 'coworker', 'friend', 'family'). This allows precise identification of contact groups without manual filtering of search results.
[api-00280] For file system filtering operations: use show_directory API with 'substring' parameter to filter by file extension (e.g., '.pdf') and 'entry_type' parameter set to 'files' to only return files (not directories). Set 'recursive=true' to search subdirectories. This approach is efficient for finding all files of a specific type within a directory hierarchy.
[api-00283] For 'most followed artist' tasks: use show_following_artists API with pagination to collect all followed artists, then find the maximum follower_count. The API returns follower_count directly for each artist, eliminating the need for additional show_artist API calls to get follower information, making this approach more efficient.
[api-00284] For 'least followed artist' tasks: use show_following_artists API with pagination to collect all followed artists, then find the minimum follower_count. The API returns follower_count directly for each artist, eliminating the need for additional show_artist API calls to get follower information.
[api-00297] For Spotify playlist sharing: use show_playlist API to retrieve the shareable_link field after creating a playlist. This provides the URL needed for sharing playlists with others via text messages or other communication methods.
[api-00308] For Spotify playback operations: always include the access_token parameter in play_music API calls, even for album or playlist playback. The API requires authentication for all operations including playback, not just data retrieval operations.
[api-00335] For partner identification in messaging tasks: use search_contacts API with relationship='partner' parameter to accurately identify the partner contact from the phone app's authoritative relationship data. This ensures precise targeting based on the canonical relationship definition rather than name-based assumptions.
[api-00349] For Venmo payment request queries: use show_received_payment_requests API with pagination to collect all requests, then filter by date range locally since the API doesn't support native date filtering parameters. This approach ensures complete data collection for accurate financial calculations.
[api-00355] For Venmo friend tracking over time: use search_friends API with pagination and filter by the friends_since field to identify friendships established within specific date ranges. The API returns friends_since in ISO format (e.g., '2019-01-01T00:00:00') which can be directly compared with other ISO format date strings for chronological filtering.
## USEFUL CODE SNIPPETS AND TEMPLATES

## COMMON MISTAKES AND CORRECT STRATEGIES

[cms-00010] Avoid relying solely on email comparison for contact matching - some contacts may only have phone numbers, and some platform connections may be based on phone numbers rather than emails. Always collect both email and phone identifiers from both sources for comprehensive matching.
[cms-00014] When comparing contacts across platforms for friend synchronization, ensure you collect ALL identifier types (email AND phone) from BOTH sources. For Venmo friends, use search_friends API to get both email and phone identifiers, then compare against phone contact identifiers using both email AND phone matching to identify friends to add/remove.
[cms-00017] For Spotify queue management, use song_id comparison rather than title matching for accurate identification of songs. Title matching can lead to false positives/negatives due to duplicate titles or formatting differences.
[cms-00021] When removing songs from Spotify queue, never remove by song_id directly - the remove_song_from_queue API requires position parameter. First identify songs by song_id comparison, then remove by their positions from the end first to maintain queue integrity.
[cms-00026] For file system operations: never assume API parameter names - different file system APIs use different parameter naming conventions. Always check API documentation first. For example: directory_exists uses 'directory_path' parameter, not 'path'; move_file uses 'source_file_path' and 'destination_file_path', not 'source_path' and 'destination_path'.
[cms-00029] When performing file system operations with directory creation, avoid creating extraneous directories. File move operations might automatically create parent directories, so only explicitly create the target directories needed for the final structure. Always include cleanup logic to remove any accidentally created directories.
[cms-00032] When reorganizing files, avoid creating directories that will become empty after file moves. Always include directory existence checks before creation and implement cleanup logic to remove any accidentally created empty directories that don't belong to the final structure.
[cms-00038] Before performing destructive operations (remove/add songs from playlists), always check the current state of the system to avoid errors from stale data or previous operations. Retrieve fresh playlist contents immediately before modification to ensure accurate state information.
[cms-00041] Before performing playlist modification operations (remove/add songs), always retrieve fresh playlist contents to check current state. Songs may have been already moved by previous operations or system automation, leading to 'song not in playlist' or 'song already in playlist' errors if using stale data.
[cms-00043] When creating new playlists for archiving or collection purposes, never assume the playlist will be empty initially. Always retrieve the current contents immediately after creation to check for existing items before attempting to add new ones. Some playlists may be automatically populated or may have been created previously with content.
[cms-00050] Avoid making assumptions about relationship counts in financial settlement tasks. Never assume the number of participants based on Venmo friends lists or other secondary sources. Always use the Phone app's contact relationships as the authoritative source for identifying roommates, friends, or family members involved in expense sharing scenarios.
[cms-00055] When matching songs across different systems (e.g., Simple Note to Spotify), avoid relying solely on exact title matching which can fail due to formatting differences, featured artists, or remix versions. Instead: (1) Use multiple matching criteria including both title and artist information when available, (2) Implement fuzzy matching or similarity scoring rather than exact string comparison, (3) Check multiple search results for better matches, and (4) Prefer using the user's actual library data (liked songs, playlists) over search results when possible for higher accuracy.
[cms-00058] Avoid using global string replacement for structured content updates. Instead, parse content line by line, identify the specific lines needing updates using precise pattern matching, and modify only those lines. This prevents unintended changes to content that might contain similar patterns but shouldn't be modified.
[cms-00060] When searching for songs across different systems (Simple Note to Spotify), avoid relying solely on exact title and artist matching which can fail due to formatting variations, featured artists, or punctuation differences. Instead: (1) Use fuzzy matching with similarity thresholds (e.g., case-insensitive comparison, ignoring punctuation), (2) Check multiple search results for better matches when exact match fails, (3) Consider using the user's actual library data (liked songs, playlists) for more accurate matching when available.
[cms-00061] When updating structured content in notes, avoid using global string replacement which can cause unintended changes if patterns appear multiple times. Instead: (1) Parse content line by line, (2) Identify specific lines needing updates using precise pattern matching, (3) Reconstruct the content with only the targeted lines modified, (4) Use the update_note API with the complete reconstructed content rather than trying to patch individual sections.
[cms-00074] Avoid assuming static state in financial operations. Payment request statuses can change dynamically during execution (user or system actions). Always retrieve fresh status immediately before each approval operation and implement incremental processing with balance verification between operations to handle dynamic state changes.
[cms-00079] Avoid trial-and-error approaches for fund addition in financial operations. Instead: (1) Check individual payment card limits using show_payment_card API first, (2) Start with small test transactions to verify card capabilities, (3) Implement systematic fund addition with incremental amounts based on verified limits, and (4) Prioritize request approval based on amount or priority when funds are insufficient for all requests.
[cms-00103] Avoid using direct floating-point arithmetic for monetary calculations without proper rounding. Floating-point operations can introduce precision errors (e.g., 700 * 1.15 = 804.9999999999999 instead of 805.00). Always use rounding to 2 decimal places: corrected_amount = round(original_amount * 1.15, 2) to ensure exact monetary amounts for financial transactions.
[cms-00105] Avoid confusing 'songs in playlists' with 'explicitly liked songs' in Spotify context. 'Liked songs' specifically refers to songs the user has explicitly marked as liked (using the heart icon/like function), not songs that are merely in playlists. Always use show_liked_songs API for accessing explicitly liked content rather than inferring from playlist membership.
[cms-00108] Avoid line-by-line parsing for quote collections with attribution on separate lines. Instead: (1) Split content by quote markers (' - ') to isolate individual quote blocks, (2) Process each block to separate quote text from attribution using pattern matching, (3) Handle multi-line quotes by treating them as cohesive blocks rather than individual lines to preserve the complete quote-attribution relationship.
[cms-00110] Avoid making assumptions about content formatting patterns without first examining the actual data structure. Instead: (1) Print the raw content with line numbers to visualize the structure, (2) Identify the actual patterns used in the content (e.g., '- ' vs ' - '), (3) Implement parsing logic based on the observed patterns rather than assumed patterns, (4) Test parsing on small samples before processing the entire content.
[cms-00113] Avoid assuming API response structures without verification. For Spotify song data, artist information is typically stored in an 'artists' array rather than a single 'artist' field. Always check API documentation (shr-00005) before accessing fields to avoid KeyError exceptions and ensure accurate data extraction.
[cms-00115] When searching for songs from Simple Note content formatted as 'Song Title by Artist', avoid using the full string including artist names for Spotify searches. Instead, extract just the song title portion before ' by ' to better match Spotify's song-only title format and improve search accuracy.
[cms-00118] Avoid making assumptions about API response message formats for success/failure detection. Instead of checking for specific words like 'success' in response messages, either: (1) Check the API documentation for the exact response structure, (2) Use try-catch error handling, or (3) Verify the actual system state after operations (e.g., check playlist contents after adding songs) rather than relying on message parsing which can be inconsistent across APIs.
[cms-00125] When collecting songs from multiple Spotify sources (liked songs, album songs, playlist songs), be aware of inconsistent field naming across APIs. The show_liked_songs API returns 'song_id' field while show_album and show_playlist APIs return 'id' field for songs. Always check API documentation for each source to use the correct field name when extracting song identifiers to avoid KeyError exceptions during data collection.
[cms-00129] Avoid relying on API response message parsing for success detection in playlist operations. Instead, always verify the actual system state using show_playlist() after create_playlist operations, as some APIs may automatically populate playlists with provided content, making individual song addition operations unnecessary and potentially misleading when checking response messages.
[cms-00139] Avoid assuming API response structures without verification. For Spotify album data, song durations are not included in show_album responses - always use show_song API to get duration information for accurate playback time calculations.
[cms-00141] Avoid assuming access tokens remain valid throughout extended multi-step operations. Instead: (1) Store login credentials for potential re-authentication, (2) Perform time-sensitive operations immediately after login, (3) Implement token refresh logic if supported by the API, (4) Handle 401 errors gracefully with re-authentication retries to ensure operation completion.
[cms-00145] Avoid assuming balance transfers are the only payment method. Instead: (1) Check create_transaction API documentation for direct payment options using payment_card_id, (2) Use direct card payments when Venmo balance is insufficient, (3) Verify all available payment cards through both Venmo and supervisor sources to identify additional payment options not currently linked to Venmo.
[cms-00154] When adding funds to Venmo balance using payment cards, always check the card expiry date before attempting to use it. Expired cards will cause transaction failures. Use show_payment_cards API to check expiry_year and expiry_month fields, and only use cards with future expiration dates to ensure successful fund transfers.
[cms-00155] Avoid assuming card expiry based solely on date comparison without testing. Some payment systems may allow card usage through the expiry month. Instead: (1) Check expiry_year and expiry_month fields using show_payment_cards API, (2) Try adding a small test amount with each potentially valid card rather than assuming expiry based on date comparison alone, (3) Only exclude cards with expiry dates clearly in the past (previous months), not current month expiry dates.
[cms-00157] Avoid using broad content-based searches when looking for messages from specific contacts. Instead: (1) First identify the contact using search_contacts to get their phone number, (2) Use search_text_messages with the phone_number parameter for precise filtering, (3) This approach ensures you only get messages actually from that contact rather than messages that merely mention their name.
[cms-00160] Avoid using overly specific search queries when processing natural language responses. Instead: (1) Use broader event-related terms initially, (2) Check all messages from each contact when specific searches fail, (3) Implement comprehensive keyword matching for both positive and negative response patterns, and (4) Verify the final results match expectations by checking for realistic response distributions.
[cms-00162] Avoid assuming file names based on task descriptions. Instead: (1) First explore the target directory using show_directory() to identify the exact file name, (2) Verify the file exists before attempting operations, (3) Only proceed with file operations after confirming the correct file path through directory exploration.
[cms-00165] Avoid assuming parameter names based on intuitive naming rather than API documentation. Different APIs may use different parameter names for similar operations (e.g., 'user_email' vs 'friend_email' for friend addition). Always check API documentation for exact parameter names before calling APIs to avoid validation errors, even when the parameter purpose seems obvious.
[cms-00167] Avoid using transaction email addresses directly for friend operations without identity verification. Instead: (1) First resolve transaction recipient identities through the Phone app's contact relationships using search_contacts with the email addresses found in transactions, (2) Use the verified contact information from the Phone app for friend operations, (3) Implement proper error handling for cases where transaction email addresses don't correspond to known contacts. This ensures friend operations are performed on verified identities rather than potentially stale transaction data.
[cms-00169] Avoid interpreting friend management tasks as complete relationship replacement based on single-period transactions. Instead: (1) Add only new contacts from the specified transaction period, (2) Maintain existing friend relationships regardless of recent transaction activity, (3) Only remove friends when explicitly instructed or when there's a clear policy reason, not based solely on absence from a single month's transactions.
[cms-00196] Avoid assuming API failures are permanent without proper diagnosis. When encountering API errors like 'NoneType' object is not iterable: (1) Implement try-catch blocks to capture detailed error messages from API responses, (2) Check if preconditions are met (e.g., logout state for signup), (3) Test with simplified parameters to isolate issues, (4) Verify API documentation for hidden constraints, and (5) Explore alternative approaches when primary methods consistently fail.
[cms-00199] Avoid assuming API failures are permanent without proper diagnosis. When encountering API errors like 'NoneType' object is not iterable: (1) Implement try-catch blocks to capture detailed error messages from API responses, (2) Check if preconditions are met (e.g., logout state for signup), (3) Test with simplified parameters to isolate issues, (4) Verify API documentation for hidden constraints, and (5) Explore alternative approaches when primary methods consistently fail.
[cms-00202] Avoid assuming API failures are permanent without proper diagnosis. When encountering API errors like 'NoneType' object is not iterable: (1) Implement try-catch blocks to capture detailed error messages from API responses, (2) Check if preconditions are met (e.g., logout state for signup), (3) Test with simplified parameters to isolate issues, (4) Verify API documentation for hidden constraints, and (5) Explore alternative approaches when primary methods consistently fail.
[cms-00215] Avoid recording payments on accounting platforms without verifying corresponding transactions on payment platforms. Instead: (1) Identify expenses on the accounting platform (Splitwise), (2) Search for exact matching transactions on the payment platform (Venmo) by amount and recipient, (3) Use the payment platform's receipt download function to get actual proof, (4) Only record payments for expenses that have verified transactions with proper documentation.
[cms-00218] Avoid assuming all payments must correspond to expenses from the specified timeframe. Instead: (1) Focus on exact amount and recipient matches within the given date ranges, (2) Process only clear verifiable matches, (3) Accept that some payments may be for older expenses or unrelated transactions, and (4) Complete the task after processing verified matches rather than exhaustive searching for uncertain matches.
[cms-00221] Avoid assuming all messages containing service names are actual invitations. Instead: (1) Verify message content contains invitation-specific language and codes, (2) Implement content filtering to exclude casual mentions from processing, (3) Use multiple pattern matching techniques to extract valid invitation codes, and (4) Handle different invitation formats that may be used by the service.
[cms-00222] Avoid attempting operations on already-processed messages without checking their current state. Instead: (1) Implement proper error handling for 409/404 errors indicating already deleted or non-existent items, (2) Check message existence before attempting deletion operations, (3) Use try-catch blocks to handle expected API errors gracefully, and (4) Log processing status to avoid redundant operations.
[cms-00230] Avoid manual string splitting for code extraction from messages which can include unwanted punctuation. Instead: (1) Use regex pattern matching with specific patterns (e.g., r'code =>\s*([a-zA-Z0-9]+)') to extract clean alphanumeric codes, (2) Handle different invitation formats that may include trailing punctuation or spaces, and (3) Validate extracted codes before using them in API calls to avoid errors from malformed codes.
[cms-00234] Avoid relying on group-level expense queries for verification immediately after creating expenses. Instead: (1) Store the expense IDs returned from successful record_expense calls, (2) Check API documentation to understand if show_group_expenses has pagination or filtering limitations, (3) Implement retry logic for eventual consistency if needed, (4) Verify individual expenses using their IDs rather than group aggregates to ensure accurate verification of creation operations.
[cms-00237] Avoid simple string splitting for natural language expense descriptions with comma-separated debtor lists. Instead: (1) Split by commas first to get initial list items, (2) Check if the last item contains 'and' and split it further, (3) Trim whitespace from all resulting names to ensure accurate debtor identification in financial settlement operations.
[cms-00247] Avoid assuming search_results indicate user existence without exact email verification. When using venmo.search_users(), always check that at least one result has an exact email match to the target user before attempting create_transaction, as search may return partial matches that don't correspond to actual valid users for transactions.
[cms-00255] Avoid mixing email addresses and phone numbers in the same set when comparing contacts across platforms. Instead: (1) Create separate sets for Venmo emails, Venmo phones, Phone emails, and Phone phones, (2) For removal: Check if each Venmo friend has either their email OR phone in the Phone contacts' identifiers, (3) For addition: Check if each Phone contact has either their email OR phone in the Venmo friends' identifiers, but only attempt to add using email addresses (since Venmo API requires emails), (4) Handle contacts without emails by skipping them or finding alternative approaches.
[cms-00257] When removing multiple items from a queue by position, avoid using the original positions after each removal operation as queue positions shift dynamically. Instead: (1) sort the original positions in descending order (highest to lowest) and remove in that exact order without re-fetching the queue, OR (2) repeatedly get the current queue state after each removal to account for position shifts. The first approach is more efficient but requires careful ordering to ensure each removal doesn't affect subsequent operations.
[cms-00264] When moving content between playlists or collections, expect and handle duplicate addition errors (422 status) gracefully as they indicate the content is already in the target location, which is often the desired outcome rather than an actual failure. This is particularly common when the same item exists in multiple source locations but should only be added once to the target collection.
[cms-00268] Avoid assuming parameter naming consistency across different APIs within the same app. Different APIs may use different parameter names for similar concepts (e.g., 'user_email' for create_payment_request vs 'receiver_email' for create_transaction in Venmo). Always check API documentation for exact parameter names before calling APIs to avoid validation errors, even when the parameter purpose seems similar across different API calls.
[cms-00282] Avoid assuming API response field names based on similar APIs within the same app. Different APIs may use different field naming conventions (e.g., 'id' vs 'song_id'). Always check the API documentation for the exact response schema using apis.api_docs.show_api_doc() before accessing any fields to prevent KeyError exceptions and ensure accurate data extraction.
[cms-00286] Avoid confusing 'songs in libraries/playlists' with 'explicitly liked songs' in Spotify context. 'Liked songs' specifically refers to songs the user has explicitly marked as liked (using the heart icon/like function), not songs that are merely in libraries or playlists. Always use show_liked_songs API for accessing explicitly liked content rather than inferring from library or playlist membership.
[cms-00301] Avoid constructing shareable URLs manually for playlist sharing tasks. Instead, always use the API-provided shareable_link field from show_playlist() which ensures the URL format is correct and the playlist is properly configured for sharing. Manual URL construction can result in incorrect or inaccessible links even when the playlist appears to be public.
[cms-00303] When creating playlists from multiple liked sources (songs, albums, playlists): always use a set to track unique song IDs to avoid duplicate addition errors (422 status codes) and ensure efficient processing. Maintain the set throughout collection from all sources, then verify the final playlist contains the expected number of unique songs after all additions are complete.
[cms-00309] Avoid assuming authentication is only needed for data retrieval APIs. All Spotify API calls including playback operations (play_music, pause_music, etc.) require the access_token parameter. Always check API documentation for authentication requirements before calling any API endpoint.
[cms-00310] Avoid using external libraries or functions not explicitly available in restricted execution environments. Functions like time.sleep() are typically not available and should not be used for rate limiting. Instead, rely on the natural pacing of API calls as the environment handles rate limiting appropriately without manual delays.
[cms-00313] Avoid attempting transactions without first verifying payment card expiration dates and available funds. Instead: (1) Check expiry_year and expiry_month fields using show_payment_cards API, (2) Test with small amounts to verify card capabilities, (3) Only proceed with full transactions after confirming both card validity and sufficient funds, (4) Provide clear error messages explaining specific financial limitations when transactions cannot be completed.
[cms-00319] Avoid using simplistic name matching when resolving identities across different data sources (e.g., message senders to CSV entries). Instead: (1) Use the most specific identifiers available (like contact_id from messages) rather than parsed names, (2) Implement exact matching with fallback strategies for name variations, (3) Verify matches against authoritative contact lists when possible, and (4) Handle cases where multiple contacts might share the same first name by using additional identifying information.
[cms-00333] Avoid complex nested expressions within f-strings that can cause syntax errors. When using dictionary access patterns like `data[complex_expression]` within f-strings, extract the key to a variable first: `key = complex_expression; print(f"{data[key]}")` to prevent syntax errors from mismatched brackets or quotes.
[cms-00341] Avoid making assumptions about content formatting patterns without first examining the actual data structure. Instead: (1) Print the raw content with line numbers to visualize the structure, (2) Identify the actual patterns used in the content (e.g., '- ' vs ' - '), (3) Implement parsing logic based on the observed patterns rather than assumed patterns, (4) Test parsing on small samples before processing the entire content.
[cms-00345] When searching for specific habit names in tracking logs, always examine the actual data structure first to identify the exact naming convention used (e.g., underscores vs hyphens). Task descriptions may use different phrasing than the actual stored data format, so print and inspect sample content to verify the exact pattern before implementing search logic.
[cms-00351] Avoid assuming API failures are permanent without proper diagnosis. When encountering API errors like 'NoneType' object is not iterable: (1) Implement try-catch blocks to capture detailed error messages from API responses, (2) Check if preconditions are met (e.g., logout state for signup), (3) Test with simplified parameters to isolate issues, (4) Verify API documentation for hidden constraints, and (5) Explore alternative approaches when primary methods consistently fail.
[cms-00354] Avoid assuming API failures indicate user error when following proper procedures. When encountering persistent API errors like 'NoneType' object is not iterable despite correct parameter usage and authentication: (1) Implement try-catch blocks to capture detailed API response messages for better diagnosis, (2) Verify if the environment supports the specific operation programmatically, (3) Explore alternative approaches or workarounds when primary methods fail, (4) Complete whatever portions of the task are actually achievable within system constraints, and (5) Document the limitations encountered for future reference.
## PROBLEM-SOLVING HEURISTICS AND WORKFLOWS
[psw-00002] Remember you can use the variables in your code in subsequent code blocks.
[psw-00007] Many APIs return items in "pages". Make sure to run through all the pages by looping over `page_index`.

## VERIFICATION CHECKLIST

[vc-00011] Verify that friend addition operations succeeded by checking API responses for errors (e.g., 'user not found' for contacts without accounts on the target platform). Implement proper error handling for cases where contacts don't have accounts on the target platform.
[vc-00012] When APIs return inconsistent or questionable results (e.g., search_friends showing different results than expected), use alternative verification methods. For friend operations, trust the add_friend/remove_friend API responses over potentially cached search results.
[vc-00015] When comparing platform contacts for synchronization, verify that the comparison logic uses both email AND phone identifiers from both sources. For each Venmo friend, check if either their email OR phone number exists in the phone contacts identifiers set before deciding to remove them.
[vc-00030] After file reorganization operations, verify the final directory structure matches the expected format. Check for and clean up any empty directories that were accidentally created during the process to maintain system cleanliness.
[vc-00033] After file reorganization, verify that no extraneous directories were created during the process. Check for and remove any empty directories that don't match the target structure pattern to maintain system cleanliness.
[vc-00039] After processing formatted file data, verify that the extracted identifiers match the target system's format. For Spotify song matching, ensure extracted titles match Spotify's song-only format rather than the file's artist-included format.
[vc-00042] After identifying songs to move between playlists, verify the current state of both source and target playlists before performing removal/addition operations. Check if songs are still in source playlists before removal and not already in target playlists before addition to avoid redundant API calls and errors.
[vc-00044] After modifying Spotify queue contents (adding/removing songs), verify the queue state using show_song_queue() to confirm the desired songs are present before proceeding with operations like shuffling or playback. This ensures the queue contains exactly the expected content as requested.
[vc-00047] After resetting Spotify queue with recommendations: verify the queue contains the expected number of songs using show_song_queue() and confirm playback has started with the shuffled content. This ensures the task requirements (reset, shuffle, play) have been fully met.
[vc-00051] Before performing financial transactions for expense sharing: verify the exact number of participants by checking Phone app contact relationships. Ensure calculations are based on the actual count of people involved rather than assumptions from secondary sources like Venmo friends lists.
[vc-00059] After updating note content with external data, verify the final content matches the expected format by retrieving the updated note and checking that all intended changes were applied correctly. This ensures data integrity and confirms the task requirements have been fully met.
[vc-00063] After updating note content with external data, verify that all intended changes were applied correctly by retrieving the updated note and checking that: (1) All placeholder values have been replaced with actual data, (2) No unintended changes were made to other parts of the content, (3) The formatting remains consistent with the original structure.
[vc-00066] After creating or updating habit tracking notes, verify the content matches expectations by: (1) Checking that all habit entries are preserved with correct values, (2) Confirming the date in the title matches the current date, and (3) Ensuring only the intended modifications were made without unintended changes to other content.
[vc-00068] After creating or updating habit tracking notes, verify that: (1) The date in the title matches the current date, (2) All habit entries are preserved with correct values, (3) Only the intended modifications were made without unintended changes to other content, and (4) The note structure remains consistent with the template format.
[vc-00075] Before approving payment requests: verify current Venmo balance and check individual payment card limits with small test transactions before attempting large balance additions. This prevents 'insufficient funds' errors and ensures successful payment processing.
[vc-00086] After processing collaborative playlist updates: verify that all requested changes were applied by comparing the final playlist state against the parsed suggestions. Check that all songs to remove were successfully removed and all songs to add were successfully added, and confirm the total song count matches expectations.
[vc-00090] After processing financial transactions from expense notes: verify that all parsed transactions were successfully executed by checking API responses for confirmation messages and ensuring the count of successful operations matches the count of parsed expense items from the note.
[vc-00092] After processing financial transactions from expense notes: verify that all parsed transactions were successfully executed by checking API responses for confirmation messages and ensuring the count of successful operations matches the count of parsed expense items from the note.
[vc-00095] After retrieving workout information from notes: verify that the current day was correctly identified using datetime.datetime.now(), confirm the parsed duration matches the expected format (integer minutes), and ensure the note structure was parsed correctly without missing any relevant sections.
[vc-00097] After retrieving workout information from notes: verify that the current day was correctly identified using datetime.datetime.now(), confirm the parsed duration matches the expected format (integer minutes), and ensure the note structure was parsed correctly without missing any relevant sections.
[vc-00101] After processing payment request corrections: verify that (1) the incorrect payment request was successfully denied, (2) the corrected transaction was sent with the right amount and explanatory note, and (3) the recipient's identity was confirmed through authoritative Phone app contact relationships to ensure the correction reaches the intended roommate.
[vc-00114] After collecting artist counts from multiple playlists: verify that song deduplication was successful by checking that the total unique song count matches expectations and that artist song counts reflect only unique songs (not counting the same song multiple times across different playlists).
[vc-00117] After creating playlists from external song sources: verify that all songs were successfully added by comparing the final playlist song count against the source list count, and check that no duplicate addition errors occurred during the batch operation.
[vc-00119] After adding songs to playlists, verify the operation was successful by checking the actual playlist contents using show_playlist() rather than relying on API response message parsing. This ensures accurate verification of song additions regardless of API response format variations.
[vc-00122] After parsing note content for completion counts: verify that the parsing logic correctly identifies all completion markers ([x]) and doesn't miscount due to formatting variations. Check that the final count matches the visible completed items in the note content to ensure accurate reporting.
[vc-00124] Before applying date filters for 'this year' or current time periods, verify the actual current year in the execution environment by: (1) Checking datetime.datetime.now().year, (2) Examining sample transaction data to confirm what year the system is actually operating in, and (3) Adjusting date filters accordingly based on the verified current year.
[vc-00128] After creating and populating a playlist: verify that (1) all liked songs were successfully added by comparing the final playlist song count against the source liked songs count, (2) the playlist is set to public if sharing is required, and (3) the shareable link is accessible before sending it to recipients.
[vc-00130] After creating a playlist: verify the actual playlist contents using show_playlist() to confirm the expected songs were added, rather than relying on API response message parsing. This is especially important when the create_playlist API may automatically populate the playlist with collected content, making individual song addition operations unnecessary.
[vc-00131] After approving payment requests, always re-check the Venmo balance immediately before initiating withdrawals to ensure the withdrawal amount reflects the actual remaining balance after all approvals have been processed. Financial systems have dynamic state that changes with each transaction, so never assume balances remain static between operations.
[vc-00142] After playing an album for extended offline playback, always verify the queue contents using show_song_queue() to ensure all album songs are properly queued for continuous playback. Check that: (1) The queue contains the expected number of songs from the album, (2) The total queue duration meets the required time threshold, and (3) All songs in the queue are downloaded for offline playback.
[vc-00146] Before attempting financial transactions: verify all available payment options by checking both Venmo-linked cards (show_payment_cards) and supervisor payment cards (show_payment_cards from supervisor app) to identify additional payment methods that may not be currently linked to the payment platform.
[vc-00170] After friend management operations based on transactions: verify that (1) only new contacts were added from the transaction list, (2) existing legitimate relationships were preserved unless explicitly required to be removed, and (3) the final friend list includes both transaction contacts and maintained relationships, not just transaction contacts alone.
[vc-00173] After exporting data to CSV files: verify that (1) the file was created at the correct path, (2) the header row contains 'date' as the first column followed by all data columns in the correct order, (3) date values are in yyyy-mm-dd format, (4) data values match the expected format (e.g., 'yes'/'no'), and (5) rows are sorted in the specified order (descending by default).
[vc-00176] After exporting data to CSV files from structured notes: verify that (1) search results were properly filtered to exclude unrelated content using title pattern matching, (2) all required columns are present with appropriate default values for missing data, and (3) the final file structure matches the specified format requirements including column order and sorting.
[vc-00184] After updating playlist titles with genre information: verify that the most common genre analysis was accurate by checking that (1) all songs in each playlist were considered using show_playlist API, (2) genre counts reflect the actual distribution across all songs, and (3) the updated title format matches the specified pattern with correct genre information.
[vc-00192] After retrieving habit tracking data: verify that the search captured all relevant historical notes by checking if the date range spans the expected period and implementing proper pagination to ensure no notes were missed due to page limits.
[vc-00197] After account creation attempts: verify that the account was successfully created by searching for it using multiple methods (email search, name search), implement proper error handling to capture detailed API response messages for troubleshooting, and confirm the account status through alternative verification methods when primary creation APIs fail.
[vc-00200] After account creation attempts: verify that the account was successfully created by searching for it using multiple methods (email search, name search), implement proper error handling to capture detailed API response messages for troubleshooting, and confirm the account status through alternative verification methods when primary creation APIs fail.
[vc-00201] After account creation attempts: verify that the account was successfully created by searching for it using multiple methods (email search, name search), implement proper error handling to capture detailed API response messages for troubleshooting, and confirm the account status through alternative verification methods when primary creation APIs fail.
[vc-00205] After counting friends by date filtering: verify that the date comparison logic correctly handles ISO format timestamps by checking that the target date calculation matches the expected format and that the comparison (friends_since >= target_date) works correctly for chronological ordering of ISO format strings.
[vc-00208] After liking unliked library content: verify that the count of newly liked items matches the identified difference between library content and previously liked content. This ensures all targeted items were successfully processed and no items were missed during the comparison operation.
[vc-00212] After Todoist task reassignment: verify that (1) the task was successfully reassigned to the correct person, (2) the thank you comment was posted with the correct first name, and (3) tasks without volunteer agreements were left unchanged as instructed.
[vc-00216] After recording payments between platforms: verify that (1) each payment corresponds to an actual transaction on the payment platform with matching amount and recipient, (2) actual transaction receipts were used as proof rather than placeholders, and (3) the payment description accurately reflects the transaction details from the payment platform.
[vc-00223] After processing invitation messages: verify that (1) only actual invitations were processed (not casual mentions), (2) invitation codes were correctly extracted using multiple pattern matching techniques, (3) appropriate error handling was implemented for already-processed messages, and (4) the system state reflects the intended actions (invitations accepted or messages deleted as appropriate).
[vc-00227] After processing invitation messages: verify that all messages from the target date were processed, invitations from contacts were successfully accepted (check API responses for success messages), and messages from non-contacts were successfully deleted. This ensures complete processing according to the task requirements.
[vc-00232] After recording expenses across systems: verify that all parsed expenses were successfully recorded by comparing the count of processed expenses against the count of source expense items, and ensure naming discrepancies were properly resolved using mapping tables between source identifiers and target system identifiers.
[vc-00233] After recording expenses in financial systems: always verify using the individual expense IDs returned from record_expense API calls rather than relying on group-level expense queries. Group expense APIs may have pagination, filtering, or eventual consistency issues that can show 0 expenses even when individual expenses were successfully created. Store the returned expense IDs and verify each one individually using show_expense API if needed.
[vc-00240] After processing collaborative playlist updates from Todoist comments: verify that (1) all parsed suggestions were successfully implemented by checking the final playlist state, (2) the completion comment was posted to the task, and (3) the task was marked as complete. This ensures the collaborative workflow is fully completed with proper documentation in both the music platform and project management system.
[vc-00242] After processing collaborative playlist updates from Todoist comments: verify that (1) all parsed suggestions were successfully implemented by checking the final playlist state using show_playlist(), (2) all songs to remove are no longer present, (3) all songs to add are now included, and (4) the total song count matches expectations after all modifications. This ensures the collaborative workflow is fully completed with proper verification of all requested changes.
[vc-00248] After processing financial payments from CSV data: verify that (1) all Venmo transactions were successfully sent with confirmation messages, (2) all Splitwise expenses were created with proper receipt attachments when available, and (3) the count of successful operations matches the number of entries in the source CSV file to ensure complete processing.
[vc-00256] After removing specific items from queues or playlists, always verify the actual content rather than relying on count-based assumptions. Check that the specific targeted items (by ID) are no longer present in the final state, not just that the total count changed by the expected amount. For queue modification tasks: retrieve the final queue state and verify that no songs from the original removal set remain in the queue.
[vc-00260] After file reorganization operations, always check for and remove any empty directories that were created during the process but don't belong to the final target structure. This ensures system cleanliness and prevents accumulation of unnecessary directories from intermediate operations.
[vc-00262] After file reorganization operations, verify that no empty directories remain from the original structure. Check for and remove any directories that became empty after moving files to the new target structure to maintain system cleanliness and prevent accumulation of unnecessary directories.
[vc-00272] After updating note content with external data: verify that all date format conversions were applied correctly by checking that ISO format dates (YYYY-MM-DD) were properly converted to the target format (MM/YYYY) using string slicing operations, and that no date formatting inconsistencies remain in the final content.
[vc-00274] After creating or updating habit tracking notes: always retrieve the created/updated note to verify that (1) the date in the title matches the current date, (2) all habit entries are preserved with correct values, (3) only the intended modifications were made without unintended changes to other content, and (4) the note structure remains consistent with the template format. This ensures the task requirements were fully met and prevents errors from going undetected.
[vc-00275] For file-to-note import tasks: always verify that the cheatsheet guidance [shr-00070] was consulted and followed before implementation. This ensures proper title formatting (extract basename, replace underscores with spaces, remove file extension) and content extraction (use file_data['content']) when importing files from file systems to note applications.
[vc-00292] After creating playlists from Simple Note song lists: verify that (1) the correct note was identified using specific search queries, (2) all song entries were properly parsed using the ' by ' separator pattern, (3) all songs were successfully found on Spotify, and (4) the final playlist contains the exact number of songs from the original note to ensure complete transfer without missing entries.
[vc-00294] For financial transaction analysis tasks: after retrieving transactions by search query, verify that the transaction descriptions actually match the intended purpose by examining a sample of descriptions to ensure accurate categorization (e.g., confirm 'electricity' transactions are actually utility bills rather than casual mentions).
[vc-00298] After creating playlists from multiple liked sources: verify that (1) all liked content was collected from songs, albums, and playlists using proper pagination, (2) song deduplication was successful by checking the total unique song count, (3) the playlist is set to public if sharing is required, and (4) the shareable link is accessible before sending it to recipients.
[vc-00300] After creating a playlist for sharing: verify that (1) the playlist is set to public using the 'is_public' field in show_playlist response, (2) the shareable_link field is populated with a valid URL before attempting to share it, and (3) the URL is accessible by testing it if possible.
[vc-00302] After creating playlists from multiple liked sources: verify that (1) all liked content was collected from songs, albums, and playlists using proper pagination, (2) song deduplication was successful by checking the total unique song count matches expectations, (3) all songs were successfully added to the playlist by comparing the final playlist song count against the source unique song count, and (4) the shareable link is accessible before sending it to recipients.
[vc-00304] Before withdrawing funds to payment cards: always verify the card's expiration date against the current date using expiry_year and expiry_month fields. Only proceed with withdrawal if the card is not expired (expiry_year > current_year OR (expiry_year == current_year AND expiry_month >= current_month)), or handle the error gracefully if expired to prevent failed withdrawal operations.
[vc-00305] Before withdrawing funds to payment cards: always verify the card's expiration date against the current date using expiry_year and expiry_month fields. Only proceed with withdrawal if the card is not expired (expiry_year > current_year OR (expiry_year == current_year AND expiry_month >= current_month)), or handle the error gracefully if expired to prevent failed withdrawal operations.
[vc-00316] For birthday/anniversary tasks: always verify that the current date (datetime.datetime.now()) matches the recipient's birthday before proceeding with financial transactions or communications. This ensures the task is executed on the correct date and prevents incorrect operations if the system date doesn't align with the real-world occasion.
[vc-00320] After updating data based on identity matching across different sources: verify that the matching logic correctly handled name variations and potential duplicates by checking that each update corresponds to the intended individual, especially when using first-name-only matching which can be ambiguous with similar names or name variations.
[vc-00323] After updating RSVP tracking files: verify that (1) all message responses were correctly interpreted and applied, (2) the CSV format remains consistent with the original structure, (3) no invited individuals were missed in the update process, and (4) the file was successfully saved with the updated content.
[vc-00325] After updating RSVP tracking files: verify that (1) all message responses were correctly interpreted and applied with proper date filtering, (2) friend identities were resolved through phone contacts rather than name matching, (3) the CSV format remains consistent with the original structure, (4) no invited individuals were missed in the update process, and (5) the file was successfully saved with the updated content. This ensures accurate tracking of response statuses across communication channels.
[vc-00328] After processing payment request corrections: verify that (1) all incorrect payment requests were successfully deleted, (2) new payment requests were created with the correct increased amounts while preserving all original metadata (description, privacy settings), and (3) the recipient identities were confirmed through authoritative Phone app contact relationships to ensure corrections reach the intended roommates.
[vc-00352] After account creation attempts: verify that the account was successfully created by searching for it using multiple methods (email search, name search), implement proper error handling to capture detailed API response messages for troubleshooting, and confirm the account status through alternative verification methods when primary creation APIs fail.
[vc-00356] After counting friends by date filtering: verify that the date comparison logic correctly handles ISO format timestamps by checking that the target date calculation matches the expected format and that the comparison (friends_since >= target_date) works correctly for chronological ordering of ISO format strings.
[vc-00359] For Todoist task reassignment based on comments: always verify that the commenter offering to take the task is not the current assignee before proceeding with reassignment. This prevents unnecessary reassignment operations when the current assignee comments on their own task and ensures tasks are only reassigned to different individuals who have volunteered.
## TROUBLESHOOTING AND PITFALLS:

[ts-00013] Some APIs (like search_friends) may have caching issues or return incomplete data. If you suspect API inconsistency, verify operations through alternative methods - for friend operations, use add_friend API error responses ('already in friend list') to confirm actual state rather than relying solely on search results.
## OTHERS
[misc-00003] Remember that the email addresses, access tokens and variables (e.g. spotify_password) in the example above are not valid anymore.
[misc-00008] Once you have completed the task, make sure to call apis.supervisor.complete_task(). If the task asked for some information, return it as the answer argument, i.e. call apis.supervisor.complete_task(answer=<answer>). Many tasks do not require an answer, so in those cases, just call apis.supervisor.complete_task() i.e. do not pass any argument.
[misc-00024] For Spotify navigation tasks to find downloaded songs: first fetch all downloaded song IDs using pagination, then navigate through the queue comparing song IDs against the pre-fetched set. This is more efficient than checking download status for each song individually during navigation.