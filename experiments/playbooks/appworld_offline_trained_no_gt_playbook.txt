## STRATEGIES AND HARD RULES
[shr-00001] Make sure to end code blocks with ``` followed by a newline(\n).
[shr-00005] Always look at API specifications (using apis.api_docs.show_api_doc) before calling an API.
[shr-00006] Write small chunks of code and only one chunk of code in every step. Make sure everything is working correctly before making any irreversible change.

[shr-00021] For time-sensitive operations (e.g., 'yesterday', 'last week', 'this year'), always use dynamic date calculations instead of hardcoded dates. Use Python's datetime module: `from datetime import datetime, timedelta; yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')` to ensure code works correctly regardless of execution date.
[shr-00067] When processing files from directories: Always check all available files regardless of format (e.g., both TXT and PDF) for the target content. Different file formats may require different parsing approaches, and some formats (like PDF) may contain binary content that cannot be directly parsed through standard file reading APIs.
[shr-00068] For time-based queries like 'this year': Always verify that all relevant time periods are accounted for in the available data before concluding calculations. If data is missing for some periods (e.g., only having January-April when May should exist), investigate alternative approaches or acknowledge the limitation rather than reporting incomplete results.
[shr-00071] When encountering binary file formats like PDF: Always check if the file system API provides text extraction capabilities or metadata access before concluding the data is unparseable. For PDF files, examine if the content contains extractable text patterns or if alternative approaches exist (e.g., checking file metadata, looking for corresponding TXT files with the same information, or using specialized PDF parsing libraries if available).
[shr-00074] When extracting numeric values from structured text content (e.g., bills, invoices, financial documents): Always use regex pattern matching with appropriate patterns to capture the numeric values. For dollar amounts, use patterns like r'Total Amount\s*=>\s*\$(?P<amount>\d+(?:\.\d+)?)' to reliably extract the numeric component while handling potential formatting variations.
[shr-00077] For file organization tasks based on date attributes: Always use the file system API's metadata (created_at) for date-based categorization, create destination directories first before moving files, use dynamic date calculations (datetime.now().year) instead of hardcoded values, and verify the results by checking the final directory structure and file counts.
[shr-00080] When removing content from multiple locations (e.g., library and playlists): Maintain precise mapping of content-to-location relationships to avoid unnecessary API calls and errors. Track which items are in which specific locations before attempting removal operations.
[shr-00083] When performing bulk removal operations with API rate limits: Prioritize core task completion over exhaustive verification. For removal tasks, trust the API responses and implement targeted verification (e.g., spot checking a few items) rather than full rescans of all content to avoid hitting rate limits unnecessarily.
[shr-00085] When removing content from multiple locations (library and playlists): Collect all target content IDs first, then check location membership for each item before attempting removal operations. This prevents unnecessary API calls and handles 'not found' scenarios gracefully by only calling removal APIs for content that actually exists in each location.
[shr-00089] When assessing music collections for duration-based tasks: Always prioritize checking the most content-rich sources first (liked songs, song library) before exploring playlists, as personal libraries often contain more music than curated playlists. Use show_song_library and show_liked_songs APIs first since they provide duration information directly, eliminating the need for individual show_song calls.
[shr-00094] When assessing music duration for time-sensitive tasks: Always calculate total duration from combined sources (song library + liked songs) when individual playlists are insufficient. Verify the combined duration meets or exceeds the requirement before creating playlists to ensure uninterrupted playback.
[shr-00101] When checking if 'all songs in an album are downloaded' for library cleanup tasks: Always verify the download status of each song within the context of that specific album using show_song_privates() or similar API, rather than relying on a global set of downloaded song IDs. A song being downloaded from other sources (like playlists) does not count toward an album's download status - only songs downloaded as part of that specific album matter.
[shr-00105] When cleaning up Spotify libraries based on download status: Always check download status at the individual song level using show_song_privates() for each song in context, rather than building a global set of downloaded songs. This ensures accurate assessment of both song library items (liked OR downloaded) and album library items (ALL songs downloaded in that specific album context).
[shr-00107] When processing directory structures: Always parse and extract directory names programmatically from API responses rather than hardcoding observed values. Use path manipulation techniques (e.g., path.split('/')[-1] to get the last component) to create flexible code that works regardless of specific directory names or structure changes.
[shr-00109] When performing file system operations that involve both compression and deletion, always check if the compression API supports a delete_directory parameter to handle both operations in a single call. This reduces API calls, ensures atomic operation completion, and maintains consistency between compression and deletion steps.
[shr-00112] When working with recommendation APIs: Always examine the full API response schema first to determine if it already contains needed information (genre, release_date, etc.) before making additional detail API calls. This prevents unnecessary API calls and potential data gaps if some items aren't accessible via detail APIs.
[shr-00113] For genre-specific recommendation tasks: Prefer using genre-filtered search (search_songs(genre='X')) when available instead of post-filtering recommendations, as it's more efficient and comprehensive for finding all songs of a specific genre rather than relying on the limited recommendation set.
[shr-00116] For genre-specific recommendation tasks: Always check if show_recommendations() response contains genre and release_date fields before making additional show_song() calls. If the recommendation API already provides these fields, filter directly from recommendations to avoid unnecessary API calls. Only call show_song() for songs that pass initial filtering if additional details are needed.
[shr-00118] When performing like operations on music queue content: Always check current liked status using show_liked_songs() first to identify which songs are not already liked, then only call like_song() for the remaining songs. This optimizes API calls and prevents redundant operations, especially important for queue-based tasks where songs might already be in your liked collection.
[shr-00122] For payment reversal/refund tasks: Always retrieve all sent payment requests with proper pagination, filter by recipient and status to identify the specific transaction to reverse, then use create_transaction with the same amount to the original recipient with a clear refund description explaining the reversal.
[shr-00124] For payment reversal tasks specifying 'last' or 'most recent' transactions: Always sort filtered transactions by creation date (created_at) in descending order and select the first result to identify the most recent transaction. This ensures you correctly identify the transaction referenced in temporal context terms like 'last', 'most recent', or 'yesterday'.
[shr-00125] For phone message deletion tasks: Always handle text and voice messages separately using their respective search and delete APIs (search_text_messages/delete_text_message for text, search_voice_messages/delete_voice_message for voice). Use phone_number parameter to filter by sender, implement proper pagination to find all messages, and verify deletion by checking that no messages remain from the target number.
[shr-00128] When using paginated APIs, always set page_limit to the maximum allowed value (check API documentation for constraints) to minimize the number of API calls required. This improves efficiency and reduces the risk of hitting rate limits, especially when processing large datasets. For example: `apis.phone.search_text_messages(access_token=phone_access_token, phone_number=spam_number, page_index=page_index, page_limit=20)`.
[shr-00129] For artist filtering tasks: Always use built-in API filters (genre, min_follower_count, etc.) when available rather than retrieving all data and filtering manually. This is more efficient and reduces API calls significantly.
[shr-00140] For Simple Note modification tasks: always retrieve the current content first, make targeted changes to specific lines or sections using string manipulation, and verify the changes were applied correctly. Use the update_note API with the modified content rather than trying to append or prepend content when making specific edits.
[shr-00143] For time manipulation tasks with alarm clocks: Always parse time strings properly (HH:MM format), handle hour increments with modulo arithmetic for 24-hour rollover, and format back with zero-padding to maintain proper time format. For example: parse '21:30' to extract hours and minutes, increment hour from 21 to 22, and format back as '22:30'.
[shr-00146] For alarm modification tasks: Always identify target alarms by label matching (e.g., 'Wake Up') rather than assuming position or time-based identification. Different users may have multiple alarms at similar times, so label matching ensures the correct alarm is modified.
[shr-00147] When processing alarms for enable/disable operations: Check both currently enabled and disabled alarms, as the task may require modifying alarms regardless of their current state. Only update alarms that need state changes (e.g., disable only enabled alarms) to minimize unnecessary API calls.
[shr-00150] When calculating playlist durations: First check if playlist APIs provide duration information directly before resorting to individual song API calls. If individual song calls are necessary, cache song duration information to avoid duplicate calls for the same song across multiple playlists.
[shr-00157] When processing song collections for metric analysis (play_count, like_count, duration), always check if library APIs (show_song_library, show_liked_songs) can provide the needed information before resorting to individual show_song calls. This optimization reduces API calls and improves efficiency, especially important for large collections or rate-limited environments.
[shr-00162] For payment-related tasks involving specific relationships (roommates, coworkers, etc.): Always resolve identities from authoritative sources (phone contacts) using relationship-based queries, then filter payment requests by email matching between transaction sender emails and contact emails. This ensures accurate identification of requests from the specified relationships rather than relying on name matching or other heuristics.
[shr-00166] For artist-specific song metric analysis tasks (most played, most liked, etc.): Use search_songs API with artist name query and leverage the built-in metric fields (play_count, like_count) returned in the search response to efficiently find the target without requiring additional show_song API calls for each result. This optimization reduces API calls and improves efficiency.
[shr-00169] For artist unfollowing tasks based on song preferences: always collect all relevant data first (liked songs and followed artists) using proper pagination, use set operations for efficient filtering, and verify the results after performing the operations. This ensures complete data collection and accurate filtering while minimizing API calls.
[shr-00173] For follow/unfollow operations: Always maintain a list of failed operations and implement retry logic with a reasonable limit (e.g., 3 attempts) for each failed API call. Track which artists failed to follow and retry them before considering the operation complete.
[shr-00175] When finding least-played or most-played songs from song library: Always check if show_song_library() response includes play_count field before making individual show_song() calls. If the library API already provides play_count information, use it directly to avoid unnecessary API calls and improve efficiency.
[shr-00180] For rating tasks involving songs that meet multiple criteria (e.g., in album library AND liked): Always collect both datasets with proper pagination first, then find the intersection to identify target songs before processing reviews. This ensures you only rate songs that meet all specified conditions and avoids unnecessary API calls for songs that don't meet all criteria.
[shr-00182] For relationship-based transaction filtering tasks: always resolve identities from authoritative sources (phone contacts) using relationship queries, use email matching for accurate filtering, implement proper pagination for complete data collection, and use dynamic date calculations for time-sensitive operations.
[shr-00185] For comprehensive data collection from multiple sources (song library, album library, playlists): Always use pagination with while True loops for each source to ensure complete data retrieval. Collect all unique song IDs first, then retrieve detailed information to avoid duplicate API calls and ensure all content is captured.
[shr-00189] When processing API responses for critical fields like dates or identifiers: Always implement defensive programming with explicit checks for field existence before accessing them. Use conditional logic (if 'field' in response) and handle missing data gracefully with appropriate fallbacks or error messages rather than assuming all responses will contain expected fields.
[shr-00191] When searching for songs by metadata like release_date, always check if library APIs (show_album_library, show_song_library) provide the needed information before resorting to individual show_song calls. Use library-level filtering to minimize API calls and improve efficiency, especially for tasks involving date-based comparisons across large collections.
[shr-00194] For payment reconciliation tasks: Always verify both sender identity (via email matching) AND exact payment amount match expected values from expense records before considering someone as paid. This prevents false positives where someone may have sent a different amount or for a different purpose.
[shr-00197] For payment reconciliation tasks involving time-sensitive events: Always use the note creation date as the reference point for determining the payment date range (from note_created_date-1 to current_date) rather than assuming the event occurred exactly 'yesterday' relative to execution time. This accounts for notes being created after the event and ensures all relevant payments are captured.
[shr-00199] For payment reconciliation tasks: When checking for received payments against expense records, always use the actual transaction dates from the payment platform rather than assuming the note creation date matches the event date. The note may be created after the event, so transaction date filtering should be based on the actual event date range rather than the note creation date.
[shr-00201] When verifying follow/unfollow operations: Trust individual API responses and use targeted verification (show_artist_following per artist) rather than comprehensive set operations with show_following_artists(), which may have pagination or timing issues. A 422 'already following' error actually confirms the desired state was achieved and should be treated as success.
[shr-00204] When filtering by categorical data like music genres: Always implement case-insensitive matching or check the exact case format using show_genres() API before filtering. Genre labels may vary in case (e.g., 'reggae' vs 'Reggae'), so use .lower() comparison or exact matching based on the taxonomy returned by show_genres().
[shr-00206] For artist following tasks based on playlist content: Always prefer show_playlist_library over show_playlist when song_ids are available in the library response to reduce API calls. Consider using genre-filtered search APIs when available instead of manual filtering. Implement proper error handling with retry logic for follow operations. Use set operations to efficiently manage artist IDs and minimize duplicate API calls for following status checks.
[shr-00209] For financial tasks requiring complete annual totals: When encountering unparseable file formats (like binary PDFs), always check if the file system API provides metadata extraction capabilities or alternative data access methods before concluding data is unavailable. If data remains unparseable, implement fallback strategies like estimating missing values from available data patterns or explicitly documenting the limitation in the final answer to provide context about incomplete data.
[shr-00211] For financial tasks requiring complete annual totals: When encountering unparseable binary formats like PDF, always check the filename for embedded amount information before concluding data is unavailable. Many billing systems include the amount in the filename format (e.g., '2023-05-$79.pdf'). If filename parsing fails, implement fallback estimation by calculating the average of available months and use that as a proxy for missing months, explicitly documenting this estimation approach in the final answer.
[shr-00216] When removing content from multiple locations (library and playlists): Always maintain separate tracking of content-to-location relationships. Collect song library contents and playlist contents separately, then only attempt removal operations for songs that actually exist in each specific location. This prevents unnecessary API calls and 422 'not found' errors by ensuring removal is only attempted from locations where the content actually exists.
[shr-00218] For date-based song removal tasks: Always check if show_song_library() returns release_date information before resorting to individual show_song() calls. If the library API provides release dates, filter songs at the library level to minimize API calls and improve efficiency, especially for large collections.
[shr-00219] When removing songs based on release date criteria: First collect all target song IDs from library and playlists, then check release dates in bulk using the most efficient API available (preferring library APIs over individual song calls). Only then proceed with removal operations to avoid unnecessary API calls for songs that don't meet the date criteria.
[shr-00223] For date-based song removal tasks: Always check if show_song_library() returns release_date information before resorting to individual show_song() calls. If available, filter songs at the library level first to minimize API calls, then only retrieve details for songs that pass the date filter. This optimization significantly reduces API calls for large collections.
[shr-00224] When removing songs from multiple locations (library and playlists): Maintain separate tracking of which songs are in which locations before attempting removal operations. Check library membership first using show_song_library() before calling remove_song_from_library(), and check playlist contents using show_playlist() before calling remove_song_from_playlist(). This prevents unnecessary API calls and handles 'not found' scenarios gracefully.
[shr-00225] For bulk removal verification: Use targeted verification by checking a representative sample of removed items rather than full rescans of all content. Verify that the original filtering criteria no longer return the target content instead of re-scanning the entire library/playlist structure. This prevents excessive API calls that could hit rate limits while still confirming successful removal.
[shr-00228] For playlist duration assessment tasks: Always check if show_playlist() or show_playlist_library() APIs return duration information directly before making individual show_song() calls. If duration is not available in playlist responses, prefer using show_song_library() and show_liked_songs() APIs to get duration information efficiently rather than individual song calls, as these library APIs provide duration data with significantly fewer API calls.
[shr-00231] When creating playlists for time-sensitive tasks: Always verify the total duration meets requirements before starting playback. Calculate duration from library APIs (show_song_library, show_liked_songs) rather than individual song calls, and ensure the playlist has at least the required duration plus a buffer (10-20%) to account for potential interruptions.
[shr-00236] When creating playlists for time-sensitive duration requirements: Sort available songs by duration (longest first) when adding to playlists to minimize the number of API calls needed to reach the target duration. This optimization reduces the number of add_song_to_playlist calls required while ensuring the playlist meets duration requirements efficiently.
[shr-00237] For Spotify library cleanup tasks requiring 'liked OR downloaded' songs: Always check both conditions independently using show_song_privates() for each song, rather than assuming songs not in the liked set should only be checked for download status. Some songs may be downloaded even if not explicitly liked, and both conditions should be evaluated separately to ensure accurate filtering.
[shr-00238] When checking album download status for library cleanup: For each album, always check the download status of each song within that specific album context using show_song_privates(), rather than building a global set of downloaded songs. A song being downloaded from other sources (like playlists) does not count toward an album's download status - only songs downloaded as part of that specific album matter for the 'all songs downloaded' condition.
[shr-00239] For Spotify library cleanup operations: Implement proper error handling with try-catch blocks for all removal API calls (remove_song_from_library, remove_album_from_library) to handle potential API failures gracefully and continue processing other items rather than stopping on the first error.
[shr-00240] When performing Spotify library cleanup: Cache song private information (liked status, download status) to avoid duplicate API calls for the same song across different operations. This optimization reduces API calls and improves efficiency, especially when the same song needs to be checked for multiple conditions (song library cleanup vs. album library assessment).
[shr-00243] When performing library cleanup operations: Always check current library membership using show_song_library/show_album_library before attempting removal operations to avoid unnecessary API calls and 422 'not in library' errors. The library state may change between checking criteria and performing removal, so verify actual membership immediately before removal attempts.
[shr-00244] For library cleanup tasks with potential timing issues: Trust the final library state rather than individual removal API responses. If the final library size matches the expected count after all operations, consider the task successful even if some removal operations returned 422 errors, as this indicates the content was already removed or not present.
[shr-00246] When checking if 'all songs in an album are downloaded' for library cleanup: Always use show_album() to get the complete list of songs belonging to the album, not just the song_ids from show_album_library(). The library response only shows songs from the album that are in your library, but the album may contain additional songs that need to be considered for the 'all songs downloaded' assessment.
[shr-00250] When processing directory structures for compression tasks: Always extract directory names programmatically from the directory listing response using path manipulation (e.g., os.path.basename(path) or path.split('/')[-1]) rather than hardcoding observed directory names. This ensures the code remains robust to changes in directory structure or naming conventions.
[shr-00253] When compressing directories with specific destination naming patterns (e.g., <vacation_spot>.zip), always extract the base directory name programmatically using path manipulation (e.g., os.path.basename(path) or path.split('/')[-1]) rather than hardcoding directory names. This ensures the code remains robust to changes in directory structure or naming conventions and can handle any number of subdirectories dynamically.
[shr-00255] For recommendation-based playlist creation with multiple filtering criteria (genre AND release_date): Always check if show_recommendations() response contains all needed filtering fields (genre, release_date) before making additional show_song() calls. If the recommendation API provides these fields, filter directly from recommendations to avoid unnecessary API calls. Only call show_song() for songs that pass initial filtering if additional details are needed.
[shr-00256] When creating playlists from filtered recommendations: Always verify playlist creation was successful by checking the response contains a valid playlist_id before attempting to add songs. This prevents errors when trying to add songs to a non-existent playlist.
[shr-00258] For recommendation-based filtering tasks: Always check the first recommendation response to determine if genre and release_date fields are available before making additional show_song() calls. If these fields are present in the recommendation response, filter directly from recommendations to avoid unnecessary API calls. Only call show_song() for songs that pass initial filtering if additional details are needed.
[shr-00259] When filtering by genre in recommendation tasks: Always use show_genres() API first to understand the exact genre taxonomy and implement case-insensitive matching or exact genre label matching based on the returned taxonomy, rather than assuming specific string values like 'R&B' which may have variations like 'RnB', 'R&B/Soul', etc.
[shr-00260] When creating playlists from filtered content: Implement proper error handling with retry logic for add_song_to_playlist operations to handle potential API failures gracefully. Use try-catch blocks to handle 'already in playlist' scenarios (422 errors) and continue processing remaining songs rather than treating them as failures.
[shr-00262] For queue-based operations: Always check the queue structure (position and is_current fields) to identify which songs have been played. Songs with position <= current_position have been played or are currently playing. Use this logic to process 'songs played so far' in queue-based tasks.
[shr-00264] For queue-based operations: Always use the queue structure (position and is_current fields) to identify which songs have been played. Songs with position <= current_position have been played or are currently playing. Use this logic to process 'songs played so far' in queue-based tasks.
[shr-00265] For financial calculations involving currency amounts: Always use precise decimal arithmetic (e.g., Python's Decimal module) or proper rounding to 2 decimal places to avoid floating-point precision errors. When splitting bills equally, calculate share_amount = round(total_amount / num_people, 2) and consider distributing any remainder cents fairly rather than relying on simple division.
[shr-00267] When filtering contacts by relationship type: Always check the 'relationships' array contains the target relationship (e.g., 'roommate') before counting or processing results, rather than assuming all search results match the criteria. Use: `[contact for contact in contacts if 'target_relationship' in contact['relationships']]` to ensure accurate filtering.
[shr-00271] For alarm time modification tasks (moving earlier/later): Always use datetime operations to calculate new times accurately, handling hour rollover correctly when subtracting minutes. For example: parse current time (HH:MM), subtract timedelta(minutes=X), and format back to HH:MM format to ensure proper 24-hour time handling.
[shr-00277] When calculating playlist durations requiring individual song API calls: Always implement song duration caching to avoid duplicate API calls for the same song across multiple playlists. Store song durations in a dictionary (song_id -> duration) and reuse cached values when the same song appears in different playlists, significantly reducing API calls and improving efficiency.
[shr-00279] For playlist-based song metric analysis tasks: Always verify playlist ownership by checking the owner email against the user's email when searching for playlists by name, especially when multiple playlists with the same name exist. This ensures you select the correct user-owned playlist rather than a public playlist with the same name from another user.
[shr-00282] For relationship-based filtering tasks: Always implement pagination with while True loops for ALL contact search APIs (phone.search_contacts) to ensure complete contact retrieval before proceeding with email matching operations. This prevents missing contacts that might be on subsequent pages and ensures accurate identification of all target relationships.
[shr-00286] For artist following tasks based on liked songs: First collect all target artist IDs from show_liked_songs() with proper pagination, then get all currently followed artists using show_following_artists() with pagination, use set difference to identify artists to follow, and finally follow the missing artists. This approach minimizes API calls while ensuring complete coverage, reducing from N+1 calls to just 2 bulk API calls plus the follow operations.
[shr-00288] When analyzing song metrics (like_count, play_count) across playlists: Always check if playlist APIs (show_playlist_library, show_playlist) provide the needed metric information directly before resorting to individual show_song() calls. If individual calls are necessary, implement song metric caching to avoid duplicate API calls for the same song across multiple playlists.
[shr-00292] For album library song metric analysis tasks (most-played, most-liked, etc.): Always check if show_album() API provides the needed metric information (play_count, like_count) in its song details before resorting to individual show_song() calls. If album API provides song metrics directly, use album-level data to minimize API calls. If not, individual song calls are necessary as confirmed by API documentation checks.
[shr-00293] For rating tasks involving songs that meet multiple criteria (e.g., in playlists AND liked): Always collect both datasets with proper pagination first, then find the intersection to identify target songs before processing reviews. This ensures you only rate songs that meet all specified conditions and avoids unnecessary API calls for songs that don't meet all criteria.
[shr-00296] When checking for existing reviews using show_song_reviews with user_email filter: Always implement proper pagination with while True loops to retrieve ALL pages of results, not just the first page. A user could have multiple reviews for the same song across different pages, and missing reviews could lead to creating duplicate reviews instead of updating existing ones. This is especially critical for rating tasks where the decision to create vs update depends on complete review history.
[shr-00300] For comprehensive Spotify backup tasks involving multiple sources (song library, album library, playlists): Always use pagination with while True loops for each source to ensure complete data retrieval. Collect all unique song IDs first using set operations to avoid duplicates, then retrieve detailed information to minimize API calls. This ensures all content is captured from all specified sources without repetition.
[shr-00301] When formatting CSV output with artist lists: Always extract artist names from the artists array using [artist['name'] for artist in song_info['artists']], then join them with the specified separator (e.g., '|') to create the formatted artist string. This ensures proper handling of songs with multiple artists and consistent formatting according to task requirements.
[shr-00305] When performing comprehensive Spotify backup tasks: Always extract song details (title, artists) directly from library API responses (show_song_library, show_album_library, show_playlist_library) rather than making individual show_song() calls for each song ID. The library APIs already provide the needed song information, making individual song calls redundant and inefficient. Use set operations with song_id to ensure uniqueness across different sources.
[shr-00310] For relationship-based tasks involving 'friends', 'roommates', or other personal relationships: Always resolve identities from the authoritative Phone app contacts using relationship queries (e.g., search_contacts with relationship='friend') rather than relying solely on platform-specific friend lists. Use email matching between transaction parties and contact emails for accurate filtering, as the Phone app provides the most comprehensive relationship data.
[shr-00311] For time-sensitive operations requiring date calculations (e.g., 'last 10 days including today'), always use datetime.now().date() for precise date calculations instead of datetime.now() to avoid time component issues. This ensures accurate date filtering when working with APIs that use date-only formats (YYYY-MM-DD) without time components.
[shr-00313] For comprehensive data collection from multiple Spotify sources: Always use pagination with while True loops for each library (song_library, album_library, playlist_library), collect unique song IDs using set operations to avoid duplicates, and retrieve detailed song information only once for each unique song to minimize API calls while ensuring complete coverage across all libraries.
[shr-00315] For ALL API calls that return paginated results, always implement proper pagination with while True loops and page_index incrementing until empty response, even for verification steps. Never assume a single API call will return all results, as this can lead to incomplete data collection and incorrect verification outcomes.
[shr-00316] For payment reconciliation tasks: Always use email matching between transaction sender emails and contact emails from phone contacts rather than name matching. Transaction sender names may include full names while notes may use first names only, making direct name matching unreliable. Use the Phone app as the authoritative source for identity resolution to prevent false positives in payment reconciliation.
[shr-00317] When parsing structured Simple Note content with key-value patterns (e.g., 'Name => $Amount'), use robust parsing that handles prefix characters and whitespace variations. For lines with dash prefixes, use: `clean_line = line.replace('-', '').strip()` before splitting on the separator. Alternatively, use regex patterns like r'[-\s]*(?P<name>[^=>]+)=>\s*\$(?P<amount>\d+(?:\.\d+)?)' to reliably extract name-amount pairs while handling formatting variations.
## APIs TO USE FOR SPECIFIC INFORMATION
[api-00004] You can use the "supervisor" app to get information about my accounts and use the "phone" app to get information about friends and family.

[api-00009] Spotify API schema note: apis.spotify.show_song() returns song details including 'like_count' field, which is essential for finding most-liked songs.
[api-00011] Spotify API schema note: apis.spotify.show_song() returns song details including 'play_count' field, which is essential for finding least-played or most-played songs.
[api-00013] For Spotify tasks specifying 'album library', use apis.spotify.show_album_library() to get user's saved albums. For 'playlist library', use apis.spotify.show_playlist_library(). For general 'song library', use apis.spotify.show_song_library(). Each returns different content and requires proper pagination handling.
[api-00014] Spotify API schema note: apis.spotify.show_song_reviews() returns a list of reviews for a song. Use the user_email parameter to filter for the current user's reviews specifically. This is essential for checking if a user has already reviewed content before creating new reviews.
[api-00017] When using show_song_reviews to check for existing user reviews, always include the user_email parameter with the current user's email address (e.g., user_email='brenda.webe@gmail.com') to filter for only the current user's reviews. This is essential for accurate review checking before creating or updating ratings.
[api-00018] Spotify API schema note: apis.spotify.show_song_reviews() supports pagination with page_index parameter. Always use while True loop to iterate through all pages when checking for existing reviews, especially when filtering by user_email, to ensure all reviews are retrieved and none are missed.
[api-00022] Venmo API schema note: apis.venmo.show_social_feed() returns transactions with sender/receiver objects containing email addresses. Use this to match against contact emails when filtering transactions by relationships (e.g., coworkers).
[api-00025] File System API schema note: apis.file_system.create_file() requires login first and accepts file_path with '~/' prefix for home directory paths. The content parameter should contain the full file content as a string, including headers for CSV files.
[api-00028] Spotify API schema note: apis.spotify.show_album() returns album details with a 'songs' array containing song objects with 'id' field, not a 'song_ids' array. This is essential for correctly extracting song IDs from album details when building comprehensive song libraries.
[api-00029] Spotify API schema note: apis.spotify.show_song() returns song details where the 'artists' field contains a list of dictionaries with 'id' and 'name' fields. When extracting artist names for CSV formatting, use [artist['name'] for artist in song_info['artists']] to get the artist names, then join them with the specified separator (e.g., '|').
[api-00031] Venmo API selection guide: Use show_transactions API for personal transaction history (sent/received by you) with filtering by direction, date, and specific users. Use show_social_feed API only for viewing friends' transactions in your social network. For tasks involving your own transactions (e.g., 'payments I received'), always use show_transactions with direction='received' parameter.
[api-00033] Venmo transaction filtering strategy: When filtering transactions by relationships (e.g., roommates), use email matching between transaction sender/receiver fields and contact emails obtained from phone contacts. This ensures accurate identification of transactions from specific relationships rather than relying on name matching or transaction descriptions.
[api-00034] Spotify API schema note: apis.spotify.show_recommendations() returns a list of recommended songs with 'artists' array containing artist objects with 'id' and 'name' fields. Use this API for tasks involving personalized song recommendations and artist recommendation frequency analysis.
[api-00040] Spotify API schema note: apis.spotify.show_album_library() returns album objects with 'song_ids' array containing integer song IDs, not song objects. This is essential for correctly extracting song IDs from album library when building comprehensive song collections.
[api-00044] Spotify API schema note: apis.spotify.show_playlist_library() returns playlist objects with 'song_ids' array containing integer song IDs. This is essential for efficiently extracting song IDs from playlist library when building comprehensive song collections, avoiding the need for additional show_playlist API calls.
[api-00046] Venmo payment request workflow: When sending payment requests based on Simple Note expense records, always use phone contacts to resolve name-email mappings rather than relying on transaction sender names. Transaction names may include full names while notes may use first names only, making direct matching unreliable. Use apis.phone.search_contacts() to get authoritative email addresses for each person mentioned in the note.
[api-00049] Venmo payment reconciliation strategy: When checking for received payments against expense records, always use a reasonable date range (e.g., from expense date to current date) rather than a single day to account for payments made on different dates. Also verify transaction amounts match expected amounts from expense records to accurately identify unpaid individuals and handle partial payments.
[api-00051] When reconciling payments against Simple Note expense records: always use the note creation date as a reference point for determining the payment date range (e.g., from note_created_date-1 to current_date) rather than assuming the dinner occurred exactly 'yesterday'. This accounts for notes being created after the event and ensures all relevant payments are captured.
[api-00055] Venmo transaction direction analysis: When calculating 'money sent or received' involving specific relationships, always verify the direction of each transaction by comparing sender/receiver emails against the user's identity. For transactions where the user is the sender (money sent to relationship), add the amount. For transactions where the user is the receiver (money received from relationship), also add the amount. Both directions should be summed, not netted, when the task requests 'sent or received' amounts.
[api-00057] Spotify API schema note: apis.spotify.show_genres() returns a list of available music genres. Always check this API first before filtering songs by genre to understand the exact genre labels used in the system (e.g., 'Classical', 'classical music', etc.) rather than assuming specific string values like 'classical'.
[api-00060] Spotify API optimization: When processing playlist contents for artist following tasks, prefer show_playlist_library() over show_playlist() if song_ids are available in the library response, as this reduces API calls and improves efficiency (show_playlist_library provides song_ids directly while show_playlist requires additional API calls per playlist).
[api-00064] Spotify API schema note: apis.spotify.search_songs() supports genre filtering with the 'genre' parameter. When identifying songs by genre, this API is often more reliable than inspecting individual song/album/artist metadata, as genre fields may be empty in those responses. Use with pagination to find all songs of a specific genre.
[api-00086] Spotify API optimization for removal tasks: When processing playlist contents for removal operations, prefer show_playlist_library() over show_playlist() if song_ids are available in the library response. This reduces API calls by providing song_ids directly without requiring additional show_playlist calls for each playlist.
[api-00090] Spotify API optimization for duration calculation: When calculating total duration of music collections, prefer show_song_library() and show_liked_songs() over individual show_song() calls, as these library APIs already return duration information for each song, significantly reducing API calls and improving efficiency.
[api-00102] Spotify API schema note: apis.spotify.show_song_privates() returns private user-specific information about a song including 'downloaded' (boolean) field. Use this API to check individual song download status when determining if all songs in an album are downloaded for library cleanup tasks.
[api-00111] Spotify API schema note: apis.spotify.show_song() returns song details including 'genre' field (string) and 'release_date' field (string in ISO format). Use these fields directly for genre-based filtering and date-based filtering rather than inferring genre from artist names or other attributes.
[api-00114] Spotify API schema note: apis.spotify.show_recommendations() returns song objects that may already contain 'genre' and 'release_date' fields. Always check the response schema before calling additional show_song() APIs for the same information, as this reduces API calls and improves efficiency.
[api-00119] Spotify API schema note: apis.spotify.show_song_queue() returns a list of song objects with 'song_id', 'title', 'position', and 'is_current' (boolean) fields. The queue includes both previously played songs and the currently playing song, with 'is_current' indicating which song is currently playing. This is essential for queue-based operations that need to distinguish between current and previously played songs.
[api-00123] Venmo payment reversal workflow: Use show_sent_payment_requests with status='approved' to find approved payment requests, filter by recipient name/email to identify the specific transaction, then use create_transaction to send the refund with the same amount and appropriate description.
[api-00126] Phone API schema note: apis.phone.search_text_messages() and apis.phone.search_voice_messages() both support phone_number parameter for filtering by sender number. Use these APIs to find all messages from a specific number before deletion operations, and implement proper pagination to ensure all messages are retrieved.
[api-00130] Spotify API schema note: apis.spotify.search_artists() supports genre filtering with 'genre' parameter and follower count filtering with 'min_follower_count' and 'max_follower_count' parameters. Use these filters to efficiently find artists matching specific criteria without manual post-processing.
[api-00136] Venmo API schema note: apis.venmo.create_payment_request() requires user_email parameter (string), amount (number), access_token, and optional description. Use this API to send payment requests for bill splitting tasks. The response includes payment_request_id for tracking.
[api-00141] Simple Note API schema note: apis.simple_note.update_note() requires access_token, note_id, and content parameters. The content parameter should contain the full updated content of the note, not just the changes. This is essential for correctly modifying note content while preserving the original structure and formatting.
[api-00144] Phone API schema note: apis.phone.show_alarms() returns alarm objects with 'time' field in HH:MM format, 'label' field for alarm identification, and 'enabled' boolean field for status. Use update_alarm API with time parameter to modify alarm times and enabled parameter to enable/disable alarms.
[api-00151] Spotify API optimization for playlist duration tasks: Check if show_playlist() or show_playlist_library() APIs return duration information directly before making individual show_song() calls. If duration is not available in playlist responses, use show_song_library() and show_liked_songs() APIs when possible to get duration information more efficiently than individual show_song() calls.
[api-00158] Spotify API optimization for metric analysis: When analyzing song metrics (play_count, like_count, duration) across playlists, prefer show_song_library() and show_liked_songs() over individual show_song() calls if the songs are in your library, as these library APIs provide the same metric information with potentially fewer API calls.
[api-00163] Venmo payment request workflow: When processing payment requests from specific relationships, use show_received_payment_requests with status='pending' to get all pending requests, then filter by sender email addresses obtained from phone contacts using search_contacts with relationship queries ('roommate', 'coworker'). This ensures accurate identification of requests from the target relationships.
[api-00170] Spotify API schema note: apis.spotify.show_liked_songs() returns song objects with 'artists' array containing artist objects with 'id' and 'name' fields. Use this API to extract artist IDs from liked songs when determining which artists to unfollow based on song preferences.
[api-00171] Spotify API schema note: apis.spotify.show_following_artists() returns artist objects with 'artist_id' and 'name' fields. Use this API to get all currently followed artists when determining which artists to unfollow based on song preferences.
[api-00176] Spotify API schema note: Check if apis.spotify.show_song_library() returns play_count field in its response before making individual show_song() calls for play_count analysis. This optimization can significantly reduce API calls when the library API already provides the needed metric information.
[api-00192] Spotify API schema note: apis.spotify.show_album_library() returns album objects with 'release_date' field. When searching for newest/oldest songs, use this field to pre-filter albums by release date before retrieving individual song details, significantly reducing the number of show_song API calls needed.
[api-00195] Venmo transaction verification: When checking for received payments against expense records, always implement proper pagination with while True loops for show_transactions API to ensure all transactions are captured, not just the first page. Set page_limit to the maximum allowed value (20) to minimize API calls.
[api-00207] Spotify API optimization for artist following from playlists: When processing playlist contents for artist following tasks, prefer show_playlist_library() over show_playlist() if song_ids are available in the library response. This reduces API calls by providing song_ids directly without requiring additional show_playlist calls for each playlist.
[api-00220] Spotify API optimization for date-based removal: Check if show_song_library() returns release_date field before making individual show_song() calls. If available, use library-level filtering by release date to significantly reduce API calls when removing songs based on release year criteria.
[api-00226] Spotify API optimization for removal tasks: Check if show_song_library() returns release_date field before making individual show_song() calls. If available, use library-level filtering by release date to significantly reduce API calls when removing songs based on release year criteria. This optimization is especially important for large collections where individual song calls would be inefficient.
[api-00229] Spotify API optimization for playlist duration tasks: Check if show_playlist() or show_playlist_library() APIs return duration information directly before making individual show_song() calls. If duration is not available in playlist responses, use show_song_library() and show_liked_songs() APIs when possible to get duration information more efficiently than individual show_song() calls, as these library APIs provide duration data for multiple songs in a single call.
[api-00232] Spotify API schema note: apis.spotify.create_playlist() returns a response with 'message' and 'playlist_id' fields only, not 'title'. Use the returned playlist_id for subsequent operations rather than assuming the title field exists in the response.
[api-00233] Spotify API schema note: apis.spotify.play_music() requires access_token parameter for authentication. Always include access_token when calling play_music, even when other parameters like playlist_id are provided, to avoid 401 unauthorized errors.
[api-00251] File System API schema note: apis.file_system.compress_directory() supports a delete_directory parameter that can handle both compression and deletion in a single API call. When the task requires both compressing a directory and then deleting it, always use this parameter to reduce API calls and ensure atomic operation completion.
[api-00275] Spotify API optimization for playlist duration tasks: Always check if show_playlist() response contains duration information directly before making individual show_song() calls. If not available, prefer using show_song_library() and show_liked_songs() APIs when possible to get duration information more efficiently than individual show_song() calls, as these library APIs provide duration data for multiple songs in a single call.
[api-00287] Spotify API optimization for artist following from liked songs: When following artists based on liked songs, prefer using show_following_artists() with pagination to get all currently followed artists in bulk rather than making individual show_artist_following() calls for each artist. This reduces API calls significantly, especially when dealing with large numbers of artists.
[api-00289] Spotify API optimization for playlist metric analysis: Check if show_playlist_library() or show_playlist() responses contain like_count or play_count fields before making individual show_song() calls. If available, use playlist-level metric information to significantly reduce API calls when analyzing songs across multiple playlists.
[api-00291] Spotify API schema note: apis.spotify.show_song_library() does NOT return play_count field in its response. Individual show_song() calls are required to get play_count information for least-played/most-played song analysis tasks, even though this increases API calls.
[api-00298] Venmo API selection for personal transaction tasks: For tasks involving your own transactions with specific relationships (e.g., 'transactions involving my coworkers'), always use show_transactions() API (not show_social_feed()) and filter by both directions (sent/received) to capture all transactions where you are involved with the target relationships. Use email matching between transaction parties and contact emails from phone relationships for accurate filtering.
[api-00302] Spotify API schema note: For comprehensive backup tasks, use show_song_library() for song library content, show_album_library() for album library content (which provides song_ids array), and show_playlist_library() for playlist content (which provides song_ids array). Combine these sources using set operations to get all unique song IDs before retrieving detailed song information with show_song().
[api-00306] Spotify API optimization for backup tasks: The show_song_library() response already contains song details including title and artists array. For comprehensive backup tasks, extract song information directly from library responses rather than making individual show_song() calls. This optimization reduces API calls significantly when the same information is available in bulk library responses.
## USEFUL CODE SNIPPETS AND TEMPLATES

[code-00010] Spotify workflow template: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all playlists with pagination, 4) Extract all unique song IDs, 5) Get song details with like_count, 6) Find maximum like_count song.
[code-00012] Spotify least-played song workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all songs from song library with pagination, 4) For each song, call show_song to get play_count, 5) Find minimum play_count song.
[code-00015] Spotify rating workflow template: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all liked songs with pagination, 4) For each song, call show_song_reviews with user_email filter to check existing reviews, 5) If no review exists, use review_song to create 5-star rating, 6) If review exists with rating < 5, use update_song_review to update to 5 stars, 7) If review already has 5 stars, leave unchanged.
[code-00023] Venmo coworker transaction workflow: 1) Get credentials from supervisor, 2) Login to phone app and search for coworkers by relationship, 3) Login to Venmo, 4) Get social feed with pagination, 5) Filter transactions by date (using datetime calculations) and coworker email matching, 6) Like qualifying transactions with error handling.
[code-00026] Spotify backup workflow: 1) Get credentials from supervisor, 2) Login to Spotify, 3) Collect all unique song IDs from song library, album library, and playlists with pagination, 4) Get song details for each unique ID, 5) Format CSV with headers 'Title' and 'Artists' (artists separated by '|'), 6) Login to file system, 7) Create CSV file at specified path, 8) Terminate account if requested.
[code-00035] Spotify recommendation analysis workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all recommendations with pagination (while True loop with page_index), 4) Count artist frequencies across all recommendations, 5) Identify artist with highest frequency count as most recommended.
[code-00037] Spotify least-recommended artist workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all recommendations with pagination (while True loop with page_index), 4) Count artist frequencies across all recommendations, 5) Identify artist with minimum frequency count as least recommended, 6) Handle ties consistently (e.g., alphabetical selection) when multiple artists share the same minimum frequency.
[code-00041] Spotify oldest song workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Collect all unique song IDs from song library, album library, and playlist library with proper pagination, 4) Get song details including release_date for each unique song, 5) Find song with oldest release_date.
[code-00047] Venmo payment request workflow: 1) Get credentials from supervisor, 2) Login to Simple Note and find expense note, 3) Parse note to get names and amounts, 4) Login to phone app and search for each name to get email mappings, 5) Login to Venmo, 6) Check received transactions from relevant date, 7) Compare transaction sender emails against contact emails to identify unpaid individuals, 8) Send payment requests to unpaid individuals with appropriate description.
[code-00066] Spotify indie artist following workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all playlists with pagination, 4) Extract all unique song IDs, 5) Search for indie-genre songs with pagination using search_songs(genre='indie'), 6) Find intersection between playlist songs and indie songs, 7) Extract artist IDs from matching songs, 8) Check following status for each artist using show_artist_following, 9) Follow artists not already followed, 10) Verify all artists are now followed.
[code-00091] Spotify custom playlist creation workflow: 1) Get workout duration from Simple Note, 2) Check liked songs and song library for sufficient duration, 3) If insufficient, search for additional songs using search_songs(query='workout exercise energetic'), 4) Create new playlist with create_playlist(), 5) Add all songs using add_song_to_playlist() with error handling for duplicates, 6) Verify total duration meets requirements, 7) Start playback with play_music(playlist_id=...).
[code-00095] Workout playlist creation workflow: 1) Get workout duration from Simple Note, 2) Check existing playlists for sufficient duration, 3) If insufficient, combine song library and liked songs to calculate total available duration, 4) Create new playlist if needed, 5) Add all unique songs to playlist, 6) Verify total duration meets requirements, 7) Start playback with play_music(playlist_id=...).
[code-00137] Bill splitting workflow template: 1) Get file system credentials and access bill information, 2) Use phone app to identify roommates by relationship filter, 3) Calculate equal shares (total_amount / (roommates_count + 1)) to include yourself in the split, 4) Login to Venmo, 5) Send payment requests to each roommate with appropriate description using create_payment_request API.
[code-00142] Simple Note content modification workflow: 1) Get Simple Note credentials from supervisor, 2) Login to get access_token, 3) Search for target notes using search_notes, 4) Retrieve note content with show_note, 5) Modify specific content using string replacement or manipulation, 6) Update note with update_note API using the full modified content, 7) Verify changes by retrieving the note again.
[code-00145] Alarm modification workflow: 1) Get phone credentials from supervisor, 2) Login to phone app, 3) Retrieve all alarms with pagination, 4) Identify target alarm by label matching, 5) Parse current time (HH:MM), increment/decrement hours as needed, 6) Update target alarm with new time, 7) Disable other alarms by setting enabled=False, 8) Verify changes by retrieving alarms again if needed.
[code-00156] Spotify album-based song selection workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Search for target album using search_albums(query='album_name'), 4) Extract song_ids from album search result, 5) Get song details including target metric (play_count, like_count) for each song, 6) Find song with minimum/maximum metric value, 7) Play target song using play_music(song_id=target_song_id).
[code-00160] Spotify album-based song selection workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Search for target album using search_albums(query='album_name'), 4) Extract song_ids from album search result, 5) Get song details including target metric (play_count, like_count) for each song, 6) Find song with minimum/maximum metric value, 7) Play target song using play_music(song_id=target_song_id).
[code-00165] Venmo payment request rejection workflow: 1) Get credentials from supervisor, 2) Login to phone app and search for target relationships (friends, roommates) using relationship filtering, 3) Login to Venmo, 4) Get all pending payment requests with proper pagination using show_received_payment_requests with status='pending', 5) Filter requests by matching sender emails against contact emails, 6) Reject all filtered requests using deny_payment_request API, 7) Verify completion by checking that no pending requests remain from target relationships.
[code-00179] Spotify 1-star rating workflow for non-liked songs: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all songs from song library with pagination, 4) Get all liked songs with pagination to identify non-liked songs, 5) For each non-liked song, call show_song_reviews with user_email filter to check existing reviews, 6) If no review exists, use review_song to create 1-star rating, 7) If review exists with rating > 1, use update_song_review to update to 1 star, 8) If review already has 1 star, leave unchanged, 9) Verify all target songs now have 1-star ratings.
[code-00181] Spotify multi-criteria rating workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Collect all album library songs with pagination, 4) Collect all liked songs with pagination, 5) Find intersection of both sets to identify target songs, 6) For each target song, call show_song_reviews with user_email filter to check existing reviews, 7) If no review exists, use review_song to create target rating, 8) If review exists with rating different from target, use update_song_review to update to target rating, 9) If review already has target rating, leave unchanged.
[code-00184] Venmo personal transaction filtering workflow: 1) Get credentials from supervisor, 2) Login to phone app and search for target relationships (coworkers, roommates) using relationship filtering, 3) Login to Venmo, 4) Get all transactions (both sent and received) with pagination using show_transactions, 5) Filter transactions by date range and email matching between transaction parties and contact emails, 6) Process qualifying transactions according to task requirements (like, analyze, etc.).
[code-00205] Spotify artist following from playlist workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all playlists with pagination, 4) Extract all unique song IDs, 5) Check song genres using show_song() with case-insensitive matching, 6) Extract artist IDs from matching songs, 7) Follow artists not already followed with error handling for 'already following' scenarios.
[code-00269] For Simple Note checklist modification tasks (e.g., changing [x] to [ ] for specific items): Use targeted string replacement with the exact line format. Example: `updated_content = content.replace('[x] Taking a solo backpacking trip', '[ ] Taking a solo backpacking trip')` to modify specific checklist items while preserving the rest of the note structure.
[code-00270] For Simple Note checklist modification tasks (e.g., changing [ ] to [x] for specific items): Use targeted string replacement with the exact line format. Example: `updated_content = content.replace('[ ] Specific item text', '[x] Specific item text')` to modify specific checklist items while preserving the rest of the note structure. This approach works best when the target text is unique within the note content.
[code-00278] For album-based song selection tasks (e.g., 'least listened to song from [album]'): 1) Get credentials from supervisor, 2) Login to get access_token, 3) Search for target album using search_albums(query='album_name'), 4) Extract song_ids from album search result, 5) Get song details including target metric (play_count, like_count) for each song, 6) Find song with minimum/maximum metric value, 7) Play target song using play_music(song_id=target_song_id).
[code-00294] Spotify playlist rating workflow: 1) Get credentials from supervisor, 2) Login to get access_token, 3) Get all liked songs with pagination, 4) Get all playlists with pagination, 5) Extract songs from playlists, 6) Find intersection of liked and playlist songs, 7) For each target song, call show_song_reviews with user_email filter to check existing reviews, 8) If no review exists, use review_song to create 5-star rating, 9) If review exists with rating < 5, use update_song_review to update to 5 stars, 10) If review already has 5 stars, leave unchanged.
[code-00303] Spotify comprehensive backup workflow: 1) Get credentials from supervisor, 2) Login to Spotify, 3) Collect all unique song IDs from song library, album library, and playlists with proper pagination (while True loops), 4) Get song details for each unique ID, 5) Format CSV with headers 'Title' and 'Artists' (artists separated by specified separator like '|'), 6) Login to file system, 7) Create CSV file at specified path, 8) Terminate account if requested.
## COMMON MISTAKES AND CORRECT STRATEGIES

[cms-00016] When working with review/rating APIs: Always check for existing reviews using show_[entity]_reviews with user_email filter before creating new reviews. The review_song API will fail with 409 error if a review already exists - use update_song_review instead for existing reviews that need rating changes.
[cms-00019] When using show_song_reviews with user_email filter: Never assume it returns exactly one review. Always implement proper pagination (while True loop with page_index) to retrieve ALL pages of results, as a user could have multiple reviews for the same song in rare cases, or reviews might be paginated across multiple pages.
[cms-00020] When using social/like APIs (e.g., like_transaction), always implement error handling for 'already liked' scenarios. These APIs typically return 422 errors when attempting to like content that has already been liked. Use try-catch blocks to handle these gracefully and verify the final state rather than assuming the operation succeeded.
[cms-00024] When filtering Venmo transactions by relationships: Always resolve identities from authoritative sources (phone contacts) rather than inferring from transaction descriptions or names. Use email matching between transaction sender/receiver fields and contact emails for accurate relationship filtering.
[cms-00027] When creating CSV files: Always include headers exactly as specified in the task requirements. For artist separation, use the exact separator requested (e.g., '|' instead of commas or other delimiters). Verify the file path uses the correct format (absolute starting with '/' or relative starting with '~/').
[cms-00030] When parsing structured text content with hierarchical relationships (e.g., movie titles followed by director information in Simple Note): Avoid complex hierarchical parsing that assumes specific line relationships. Instead, use pattern matching by first searching for the known target term (e.g., 'David Fincher'), then extract the immediately preceding non-indented line as the related entity (e.g., movie title). This approach is more robust than building complex state machines for parsing.
[cms-00032] When working with Venmo transactions: Never use show_social_feed for personal transaction history tasks. show_social_feed only shows transactions between friends in your social network, not your personal sent/received transactions. Always use show_transactions API with appropriate direction parameter (sent/received) for tasks involving your own transaction history.
[cms-00039] For 'most recommended artist' tasks: Always use show_recommendations API with proper pagination (while True loop with page_index) to collect all recommendations, perform frequency analysis on artist names, and identify the artist with the highest occurrence count across all recommendations. This ensures accurate results by considering the complete recommendation history.
[cms-00045] When processing Spotify playlist library: Never call show_playlist API for each playlist to get song information when show_playlist_library already provides song_ids directly in the response. This creates unnecessary API calls and reduces efficiency. Instead, directly use the song_ids field from the playlist library response: for playlist in playlist_page: all_song_ids.update(playlist['song_ids']).
[cms-00048] When matching payment status between Simple Note records and Venmo transactions: Never rely on name matching alone as transaction sender names may include full names while notes may use first names only. Always use phone contacts to resolve authoritative email mappings and match against transaction sender emails for accurate identification of who has paid.
[cms-00050] When reconciling payments against expense records: Never assume all payments occur on the same day as the expense. Use a date range that covers all possible payment dates and verify transaction amounts match expected amounts to avoid sending duplicate payment requests or missing partial payments.
[cms-00058] When filtering by categorical data like music genres: Never assume specific string values for categorical fields without first checking the authoritative source using relevant APIs (e.g., show_genres for music genres). Always verify the available taxonomy before implementing filtering logic to ensure all relevant content is captured.
[cms-00061] When following artists: Always check show_artist_following() or show_following_artists() before attempting to follow artists to avoid redundant operations and potential errors. This prevents unnecessary API calls and ensures you only follow artists not already in your following list.
[cms-00062] For follow/unfollow operations: Always implement error handling using try-catch blocks, similar to social/like APIs. The follow_artist API may return errors for already-followed artists or other edge cases that should be handled gracefully rather than assuming the operation succeeded.
[cms-00065] When verifying artist following status: Always check the exact response schema from show_artist_following API documentation. The field is called 'following' (boolean), not 'is_following'. Incorrect field name assumptions can lead to false verification results even when follow operations were successful.
[cms-00069] When working with file systems containing multiple file formats: Never assume only one file format contains parseable content. Always check all available files for the target information and develop strategies for handling different file types. For binary formats like PDF, check if alternative approaches exist (e.g., metadata extraction, checking if the file system API provides text extraction capabilities) before concluding the data is unavailable.
[cms-00072] When processing binary files: Never assume binary content is completely unparseable without first checking for text extraction capabilities or alternative data sources. Always verify if the file system API can provide readable metadata or if there are corresponding text versions of the same files before concluding that data is unavailable.
[cms-00076] When working with file system APIs: Always check API documentation for exact parameter names before calling file operations. Different file system APIs use different parameter naming conventions (e.g., 'file_path' for show_file, 'directory_path' for directory_exists, 'source_file_path' and 'destination_file_path' for move_file). Never assume parameter names based on common patterns across different APIs.
[cms-00081] When removing content from libraries or collections: Never assume content exists in all target locations. Implement proper error handling for expected 'not found' scenarios (e.g., 422 errors for 'not in library') rather than treating them as failures. Check location membership before attempting removal to optimize API calls.
[cms-00084] When verifying removal operations: Avoid exhaustive rescans of all content that consume excessive API calls and risk hitting rate limits. Instead, implement targeted verification by checking a representative sample of removed items or verifying that the original filtering criteria no longer return the target content, rather than re-scanning the entire library/playlist structure.
[cms-00087] When performing bulk removal operations: Never call show_song API multiple times for the same song. Store song details once and reuse them throughout the removal process to avoid duplicate API calls and improve efficiency, especially when the same song exists in multiple locations (library and playlists).
[cms-00092] When adding songs to playlists: Always implement error handling for 'already in playlist' scenarios (422 errors). The add_song_to_playlist API returns 422 when attempting to add duplicate songs. Use try-catch blocks to handle these gracefully and continue with the remaining songs rather than treating them as failures.
[cms-00096] When existing playlists are insufficient: Never assume you must use only playlists. Always check alternative music sources (song library, liked songs) and combine them to meet duration requirements. Creating a new playlist from combined sources is a valid strategy when existing playlists don't meet time requirements.
[cms-00098] When calculating music duration for playlist tasks: Never call show_song() for individual songs when show_song_library() and show_liked_songs() APIs already provide duration information. This creates unnecessary API calls and reduces efficiency. Instead, directly use the duration field from library API responses to calculate total duration.
[cms-00099] When adding songs to playlists: Always implement error handling for 'already in playlist' scenarios (422 errors) using try-catch blocks. The add_song_to_playlist API returns 422 when attempting to add duplicate songs. Handle these gracefully and continue with remaining songs rather than treating them as failures or assuming all additions will succeed.
[cms-00103] When determining album download status for library cleanup: Never use a global set of downloaded song IDs to check if 'all songs in an album are downloaded'. This approach incorrectly counts songs downloaded from other sources (like playlists) as contributing to an album's download status. Instead, for each album, check the download status of each song within that specific album context using show_song_privates() to accurately determine if the album should be kept.
[cms-00108] When working with file system directory operations: Never hardcode directory names observed in API outputs. Always extract directory names programmatically from the directory listing response using string manipulation to ensure the code remains robust to changes in directory structure or naming conventions.
[cms-00110] When filtering content by categorical attributes like genre: Always use the specific categorical fields provided by the API (e.g., 'genre' field for songs) rather than making assumptions based on other attributes like artist names. When API documentation shows specific fields available for filtering, use those fields directly for accurate results instead of implementing heuristic-based filtering that may miss relevant content.
[cms-00115] When processing Spotify recommendations: Never assume you need to call show_song() for each recommendation to get genre/release_date information. First check if show_recommendations() response already contains these fields to avoid unnecessary API calls and potential data gaps if some songs aren't accessible via show_song().
[cms-00117] When processing Spotify recommendations for genre-specific tasks: Never default to calling show_song() for each recommendation without first checking if show_recommendations() response already contains genre and release_date information. This creates unnecessary API calls and potential data gaps. Always examine the full API response schema first to determine if additional detail calls are needed.
[cms-00131] When following artists based on specific criteria: Never retrieve all artists and filter manually when the search_artists API provides built-in filters for genre and follower count. Using API filters directly is more efficient and reduces the number of API calls required.
[cms-00133] When calling APIs within the same app: Never assume authentication requirements are consistent across all endpoints. Always check the specific parameter requirements for each API call, as some endpoints may require access_token while others don't, even within the same application. This prevents 401 unauthorized errors that occur when access_token is missing from authenticated endpoints.
[cms-00135] When using f-strings with nested quotes or complex expressions: Avoid putting complex list comprehensions or nested quotes directly inside f-strings as this can cause syntax errors. Instead, compute the expression in a separate variable first, then reference it in the f-string. For example: `roommate_names = [f"{r['first_name']} {r['last_name']}" for r in roommates_only]; print(f"Roommates: {roommate_names}")` instead of `print(f"Roommates: {[f'{r['first_name']} {r['last_name']}' for r in roommates_only]}")`.
[cms-00138] When splitting bills equally among roommates: Always include yourself in the count when calculating per-person amounts. For N roommates, divide the total amount by (N + 1) to account for your own share, as the bill is supposed to be shared equally among all occupants including yourself.
[cms-00177] When processing Spotify album library: Never call show_album API for each album to get song information when show_album_library already provides song_ids directly in the response. This creates unnecessary API calls and reduces efficiency. Instead, directly use the song_ids field from the album library response: for album in album_page: all_song_ids.update(album['song_ids']).
[cms-00186] When parsing structured text content with hierarchical relationships (e.g., movie titles followed by director information in Simple Note): Use pattern matching by first searching for the known target term (e.g., 'David Fincher'), then extract the immediately preceding non-indented line as the related entity (e.g., movie title). This approach is more robust than building complex state machines for parsing as it handles variations in content structure more effectively.
[cms-00188] When parsing structured content with movie-director relationships in Simple Note: For director-specific filtering tasks, first identify all movies with their directors using pattern matching (e.g., lines with ' - director:' prefix), then filter movies by the target director name. This approach is more reliable than trying to parse hierarchical relationships when the task requires filtering by specific criteria like director name.
[cms-00193] When finding newest/oldest released songs: Never default to calling show_song() for all songs when show_album_library() already provides release_date information. First filter albums by release date at the library level, then only retrieve song details for songs from the most recent/oldest albums to minimize API calls and improve efficiency.
[cms-00202] When verifying artist following status: Never rely solely on set operations with show_following_artists() for verification, as this API may not return all followed artists due to pagination limitations or timing delays. Instead, use individual show_artist_following() calls for each target artist to accurately verify following status.
[cms-00208] When following artists based on playlist content: Never default to calling show_playlist for each playlist when show_playlist_library already provides song_ids directly in the response. This creates unnecessary API calls and reduces efficiency. Instead, directly use the song_ids field from the playlist library response to extract all songs across playlists.
[cms-00221] When removing songs from multiple locations: Never call show_song() multiple times for the same song across different removal operations. Store song details once and reuse them throughout the removal process to avoid duplicate API calls, especially when the same song exists in both library and playlists.
[cms-00234] When creating playlists with specific naming conventions: Always check existing playlist titles using show_playlist_library() before creating new playlists to avoid duplicate title conflicts (409 errors). Use unique, descriptive names that include date or context information to prevent naming collisions.
[cms-00247] When determining album download status for library cleanup: Never assume album['song_ids'] from show_album_library() contains all songs in the album. This only includes songs from the album that are in your library. Always call show_album() for each album to get the complete song list before checking download status to ensure accurate assessment of whether all songs in the album are downloaded.
[cms-00274] When calculating playlist durations: Never call show_playlist() multiple times for the same playlist when the song information can be cached. Always store playlist details after the first retrieval and reuse them throughout the duration calculation process to avoid duplicate API calls and improve efficiency.
[cms-00297] For personal transaction tasks involving specific relationships: Never use show_social_feed() API as it only shows transactions between friends in your social network, not your personal transactions with those relationships. Always use show_transactions() API with appropriate direction parameter and filter by both user involvement (sender/receiver email matching user's email) AND relationship party (coworker/roommate email matching from phone contacts).
[cms-00307] When performing comprehensive Spotify backup tasks: Never make individual show_song() calls for each song when the library APIs (show_song_library, show_album_library, show_playlist_library) already provide the needed song details (title, artists). This creates unnecessary API calls and reduces efficiency. Instead, extract song information directly from library responses and use set operations with song_id to ensure uniqueness across different sources.
[cms-00308] When parsing structured text content with hierarchical relationships (e.g., movie titles followed by director information in Simple Note): For director-specific filtering tasks, first search for the target director name directly in the content, then extract the immediately preceding non-indented line as the movie title. This approach is more reliable than building complex state-based parsers that make assumptions about content structure. Example: search for 'David Fincher' in the content, then extract the line immediately before each occurrence as the movie title.
[cms-00309] When parsing structured text content with movie-director relationships in Simple Note: For director-specific filtering tasks, first search for the target director name directly in the content, then extract the immediately preceding non-indented line as the movie title. This approach is more reliable than building complex state machines that make assumptions about content structure. Example: search for 'Peter Jackson' in the content, then extract the line immediately before each occurrence as the movie title.
## PROBLEM-SOLVING HEURISTICS AND WORKFLOWS
[psw-00002] Remember you can use the variables in your code in subsequent code blocks.
[psw-00007] Many APIs return items in "pages". Make sure to run through all the pages by looping over `page_index`.

## VERIFICATION CHECKLIST

[vc-00036] For 'most recommended artist' tasks: Verify you used show_recommendations API with proper pagination to collect all recommendations, performed frequency analysis on artist names, and identified the artist with the highest occurrence count across all recommended songs.
[vc-00038] For 'least recommended artist' tasks: Verify you used show_recommendations API with proper pagination to collect all recommendations, performed frequency analysis on artist names, and identified the artist with the lowest occurrence count across all recommended songs. Ensure ties are handled consistently (e.g., alphabetical selection).
[vc-00042] For 'oldest released song' tasks: Verify you collected unique song IDs from all relevant libraries (song library, album library, playlist library) using proper pagination, retrieved song details including release_date for each unique song, and correctly identified the song with the earliest release_date across all sources.
[vc-00043] For 'newest released song' tasks: Verify you collected unique song IDs from all relevant libraries (song library, album library, playlist library) using proper pagination, retrieved song details including release_date for each unique song, and correctly identified the song with the most recent release_date across all sources.
[vc-00052] For payment reconciliation tasks: verify you used the note creation date as the reference point for the payment date range (note_date-1 to current_date) rather than hardcoding 'yesterday', and verified that both sender identity AND payment amount exactly match the expected amounts from the expense note before considering someone as paid.
[vc-00053] For 'since [date] of this year' tasks: Verify you used dynamic date calculation (datetime.now().year) instead of hardcoded year values to determine the correct start date, especially when filtering transactions or other time-sensitive data. This ensures the code works correctly regardless of the actual execution year.
[vc-00054] For 'received from [relationship] since [date]' tasks: Verify you used dynamic date calculation for the start date, used show_transactions API with direction='received' parameter, logged into phone app to get authoritative contact emails for the specified relationship, filtered transactions by email matching between sender emails and contact emails, and summed amounts correctly.
[vc-00056] For 'money sent or received to [relationship]' tasks: Verify you correctly identified transaction direction by comparing sender/receiver emails against the user's email, and summed amounts from both directions (sent to relationship and received from relationship) rather than simply totaling all transaction amounts without direction analysis.
[vc-00059] For genre-based filtering tasks: Verify you first called show_genres API to understand the available genre taxonomy, then implemented appropriate filtering logic (e.g., case-insensitive matching, substring matching, or exact genre labels from show_genres) rather than assuming specific string values like 'classical'.
[vc-00063] For artist following tasks: Verify you used proper pagination when checking followed artists with show_following_artists() to ensure all followed artists are accounted for in verification, not just the first page of results.
[vc-00070] For 'this year' file-based tasks: Verify you used dynamic year calculation (datetime.now().year) to identify the correct year, checked all available files regardless of format, accounted for all months of the year in your analysis, and handled any missing data appropriately (either by finding alternative sources or acknowledging the limitation in your result).
[vc-00073] For file-based cost calculation tasks: Verify you checked all available file formats (including binary formats like PDF) for extractable cost information, attempted alternative parsing approaches for binary content, accounted for all expected time periods in your analysis, and either found alternative data sources or acknowledged the limitation in your result when some data was unavailable.
[vc-00075] For file-based cost calculation tasks using regex extraction: Verify you used appropriate regex patterns to extract numeric values from structured text content, accounted for potential formatting variations (e.g., different decimal precision, currency symbols, whitespace), and validated that all expected amounts were successfully extracted before summing.
[vc-00078] For file organization tasks: Verify you created all required destination directories first, processed each file's metadata to determine the correct category, maintained original filenames during move operations, and verified the final organization by checking file counts in each destination directory to ensure all files were properly moved.
[vc-00079] For file organization tasks with 'other' categories: Verify that empty destination directories are acceptable when no files match the 'other' criteria (e.g., Paris directory being empty when all files were created in January or April). This is a valid outcome and does not indicate an error in the organization logic.
[vc-00082] For content removal tasks: Verify removal by checking the specific criteria (e.g., 'no songs released before 2021 remain') rather than just total counts. After removal operations, specifically check that the target content no longer exists in any of the specified locations using the original filtering criteria.
[vc-00088] For content removal tasks with API rate limits: Verify removal by checking a representative sample of removed items or verifying that the original filtering criteria no longer return the target content, rather than re-scanning the entire library/playlist structure. This prevents excessive API calls that could hit rate limits while still confirming successful removal.
[vc-00093] For playlist duration tasks: Verify the final playlist duration meets or exceeds the required duration by calculating total duration from all songs (sum of song['duration'] from show_song calls or library APIs). Ensure the playlist has sufficient buffer (e.g., 10-20% extra) to account for potential interruptions or playlist changes during playback.
[vc-00097] For playlist duration tasks: Verify the final playlist duration meets or exceeds the required duration by calculating total duration from all songs (sum of song['duration'] from library APIs). Ensure the playlist has sufficient buffer to account for potential interruptions or playlist changes during playback.
[vc-00100] For playlist duration tasks: Verify you used show_song_library() and show_liked_songs() APIs to calculate total duration instead of individual show_song() calls, as library APIs already provide duration information and significantly reduce API calls. Ensure the final playlist duration meets or exceeds requirements with sufficient buffer.
[vc-00104] For Spotify library cleanup tasks requiring 'albums where all songs are downloaded': Verify you checked the download status of each song within each specific album context using show_song_privates() rather than relying on a global set of downloaded song IDs. This ensures albums are only kept when all songs from that specific album are downloaded, not when songs happen to be downloaded from other sources.
[vc-00106] For Spotify library cleanup tasks: Verify the final library sizes match the expected counts after removal operations. Check that song library contains only songs that are either liked OR downloaded, and album library contains only albums where ALL songs are downloaded. The playlist library should remain unchanged as specified in the task requirements.
[vc-00120] For queue-based music operations: Verify the queue includes both previously played songs and the current song (as indicated by the 'is_current' field in show_song_queue response), and that all specified songs in the queue were processed according to the task requirements, not just a subset.
[vc-00121] For queue-based music operations: Verify the queue includes both previously played songs and the current song (as indicated by the 'is_current' field in show_song_queue response), and that all specified songs in the queue were processed according to the task requirements, not just a subset.
[vc-00127] For message deletion tasks: Verify deletion by checking that no messages remain from the target number using search_text_messages and search_voice_messages with the target phone_number parameter. This confirms successful removal of all spam messages rather than just counting deleted items.
[vc-00132] For artist following tasks with specific criteria: Verify you used search_artists API with appropriate filters (genre, min_follower_count) to efficiently find target artists rather than retrieving all artists and filtering manually, and checked current following status before attempting to follow to avoid duplicate operations.
[vc-00134] For artist filtering tasks using search_artists API: Verify you implemented proper pagination with a while True loop and page_index incrementing until an empty response is received, ensuring all matching artists are captured regardless of how many pages exist, not just those on the first page.
[vc-00139] For bill splitting tasks: Verify you correctly calculated equal shares by dividing the total amount by (number of roommates + 1) to include yourself, used phone contacts with relationship filtering to accurately identify all roommates, and sent payment requests with the correct description and amount to each roommate.
[vc-00148] For alarm modification tasks: Verify the wake-up alarm was moved to the correct new time by checking the time field after update, and verify all other alarms were properly disabled by checking their enabled status. Confirm that only the target alarm remains enabled if the task specifies keeping only one alarm active.
[vc-00149] For alarm modification tasks: Verify the target alarm was moved to the correct new time by checking the time field after update, and verify all other alarms were properly disabled by checking their enabled status. Confirm that only the target alarm remains enabled if the task specifies keeping only one alarm active.
[vc-00152] For playlist duration calculation tasks: Verify you checked if playlist APIs provide duration information directly before making individual song API calls. If individual song calls were necessary, verify you implemented caching to avoid duplicate API calls for the same song across multiple playlists, and that you converted seconds to minutes with proper rounding to the nearest whole number as specified in the task.
[vc-00153] For playlist duration calculation tasks: Verify you calculated total duration by summing individual song durations from show_song() calls, converted seconds to minutes with proper rounding (round(seconds/60)), and identified the playlist with the minimum duration as specified in the task requirements.
[vc-00154] For playlist duration calculation tasks: Verify you checked if show_playlist() or show_playlist_library() APIs return duration information directly before making individual show_song() calls. If duration is not available in playlist responses, verify you implemented caching to avoid duplicate API calls for the same song across multiple playlists, and that you converted seconds to minutes with proper rounding to the nearest whole number as specified in the task.
[vc-00155] For album-based song selection tasks (e.g., 'least listened to song from [album]'): Verify you searched for the specific album using search_albums API, retrieved all songs from that album using show_album or song_ids from search results, checked the specific metric (play_count, like_count, etc.) for each song using show_song API, identified the song with the minimum/maximum value, and played that specific song using play_music with song_id parameter.
[vc-00159] For playlist-based song metric analysis tasks (e.g., 'most played song in playlist'): Verify you first checked if library APIs (show_song_library, show_liked_songs) could provide the needed metric information before resorting to individual show_song() calls. This optimization reduces API calls and improves efficiency, especially for playlists with many songs that are already in your library.
[vc-00161] For album-based song selection tasks (e.g., 'most listened to song from [album]'): Verify you searched for the specific album using search_albums API, retrieved all songs from that album using show_album or song_ids from search results, checked the specific metric (play_count, like_count, etc.) for each song using show_song API, identified the song with the minimum/maximum value, and played that specific song using play_music with song_id parameter.
[vc-00164] For payment request approval tasks involving specific relationships: Verify you used phone contacts with relationship queries to identify all target individuals, filtered payment requests by email matching between sender emails and contact emails, and successfully approved all identified requests using approve_payment_request API with proper error handling.
[vc-00167] For artist-specific song metric analysis tasks (e.g., 'least played song by [artist]'): Verify you used search_songs API with artist name query and leveraged the built-in metric fields (play_count, like_count) returned in the search response to efficiently find the target without requiring additional show_song API calls for each result. This optimization reduces API calls and improves efficiency.
[vc-00168] For artist-specific song metric analysis tasks (e.g., 'most played song by [artist]'): Verify you used search_songs API with artist name query and leveraged the built-in metric fields (play_count, like_count) returned in the search response to efficiently find the target without requiring additional show_song API calls for each result. This optimization reduces API calls and improves efficiency.
[vc-00172] For artist unfollowing tasks based on song preferences: verify you collected all liked songs and followed artists using proper pagination, used set operations to efficiently identify artists not in liked songs, successfully unfollowed all target artists, and confirmed the final following list only contains artists whose songs you have liked.
[vc-00174] For artist following tasks: Verify the final result by ensuring all target artist IDs are present in the final followed artists set using set operations (target_set.issubset(final_set)), not just checking if the original set is a subset. This ensures no artists were missed due to API failures or other issues.
[vc-00178] For song rating tasks: Verify you checked for existing reviews using show_song_reviews with user_email filter before creating new reviews, handled both creation (review_song) and update (update_song_review) scenarios appropriately, and ensured all target songs received 5-star ratings regardless of their previous rating status.
[vc-00183] For Venmo transaction filtering tasks involving personal transactions with specific relationships: Verify you used show_transactions API (not show_social_feed) to access your personal transaction history, filtered by both sent and received directions to capture all transactions involving the specified relationships, and used email matching between transaction parties and contact emails from phone relationships for accurate identification.
[vc-00187] For Simple Note content parsing tasks with hierarchical relationships (e.g., movie titles followed by director information): Verify you used pattern matching by first searching for the target term (e.g., 'Quentin Tarantino') then extracting the immediately preceding non-indented line as the related entity (e.g., movie title), rather than building complex state-based parsers that make assumptions about content structure.
[vc-00190] For date-based song analysis tasks: Verify you implemented proper defensive programming by checking for the existence of release_date field in each song response before comparing dates, and handled cases where release_date might be missing or malformed to avoid runtime errors.
[vc-00196] For payment reconciliation tasks: Verify you implemented proper pagination for all Venmo transaction API calls to ensure complete data collection, and verified that both sender email AND payment amount exactly match the expected values from the expense note before considering someone as paid.
[vc-00198] For payment reconciliation tasks: Verify you used the note creation date as the reference point for the payment date range (note_date-1 to current_date) rather than hardcoding 'yesterday', and verified that both sender identity AND payment amount exactly match the expected amounts from the expense note before considering someone as paid.
[vc-00200] For 'money received from [relationship] since [date]' tasks: Verify you used phone contacts with relationship queries to identify all target individuals, filtered transactions by direction='received' and date range using dynamic date calculation, implemented proper pagination to collect all transactions, and used email matching between transaction sender emails and contact emails for accurate filtering before summing amounts.
[vc-00203] For artist following tasks: Verify using individual show_artist_following() calls for each target artist rather than set operations with show_following_artists(), and treat 422 'already following' errors as confirmation of success rather than failure.
[vc-00210] For file-based cost calculation tasks with multiple formats: Verify you attempted alternative parsing approaches for binary content (PDF metadata extraction, checking for corresponding TXT files), accounted for all expected time periods in your analysis, and either found alternative data sources or explicitly acknowledged the limitation in your result when some data was unavailable to provide context about the completeness of the calculation.
[vc-00212] For file-based cost calculation tasks with unparseable formats: Verify you attempted filename parsing for amount extraction when binary content is unreadable, implemented fallback estimation strategies (like monthly averaging) for missing data, and explicitly documented any limitations or estimation methods in the final answer to provide context about the completeness of the calculation.
[vc-00213] For file-based financial tasks requiring complete annual totals: Verify that all expected months of the current year are accounted for in the available data by comparing the directory contents against the current date (using datetime.now() to determine expected months). If data is incomplete (e.g., only January-April available when current month is May), explicitly acknowledge this limitation in the final result to provide context about the completeness of the calculation.
[vc-00214] For date-based file organization tasks with specific month-to-destination mappings: Verify the destination assignment logic correctly implements the specified month mappings (e.g., March  Rome, April  Santorini, others  Berlin) by checking the conditional statements before executing file movement operations. Ensure empty destination directories are acceptable when no files match specific criteria.
[vc-00215] For file organization tasks with subdirectories: When verifying final directory structure, be aware that recursive directory listings may include both subdirectories and their contents in the item count. Always verify each destination directory separately to confirm the correct number of files were moved, rather than relying on the parent directory listing which may show subdirectories as items alongside their contents.
[vc-00217] For content removal tasks from multiple locations: Verify that removal operations were only attempted for content that actually exists in each specific location by checking location membership before removal. This prevents unnecessary API calls and ensures graceful handling of 'not found' scenarios rather than treating them as errors.
[vc-00222] For date-based song removal tasks: Verify removal by checking that no songs with release_date after the target year remain in either song library or playlists. Use targeted verification by checking a sample of removed songs rather than full rescans to avoid excessive API calls while confirming successful removal.
[vc-00227] For date-based song removal tasks: Verify removal by checking that no songs with release_date after the target year remain in either song library or playlists. Use targeted verification by checking a sample of removed songs rather than full rescans to avoid excessive API calls while confirming successful removal. Focus on verifying the absence of target content rather than comprehensive re-scanning.
[vc-00230] For playlist duration tasks: Verify you checked if playlist APIs provide duration information directly before making individual song API calls. If individual song calls were necessary, verify you implemented caching to avoid duplicate API calls for the same song across multiple playlists, and that you converted seconds to minutes with proper rounding to the nearest whole number as specified in the task requirements.
[vc-00235] For playlist creation tasks with duration requirements: Verify the created playlist has sufficient duration by calculating total duration from library APIs before playback. Ensure the playlist meets or exceeds the required duration with adequate buffer, and confirm playback started successfully using the play_music API response.
[vc-00241] For Spotify library cleanup tasks: Verify that the final song library contains only songs that are either liked OR downloaded by checking both conditions independently, not just songs that are in the liked set plus some additional downloaded songs. Ensure the 'liked OR downloaded' logic is implemented correctly by checking both conditions for each song rather than using set operations alone.
[vc-00242] For Spotify album library cleanup: Verify that albums are only kept when ALL songs within that specific album context are downloaded, not when songs happen to be downloaded from other sources. Check the download status of each song within each album individually using show_song_privates() rather than relying on a global downloaded song set.
[vc-00245] For Spotify library cleanup tasks: Verify success by checking final library sizes match expected counts rather than tracking individual removal operations. If the song library contains only songs that are liked OR downloaded, and the album library contains only albums where ALL songs are downloaded, the cleanup was successful regardless of individual API response codes.
[vc-00248] For Spotify album library cleanup requiring 'all songs downloaded': Verify you used show_album() to get the complete list of songs for each album before checking download status, rather than relying on album['song_ids'] from show_album_library() which only includes songs from the album that are in your library. This ensures all songs in the album are considered for the download status assessment.
[vc-00249] For file system compression tasks: Verify that all target directories have been successfully compressed by checking that the zip files exist in the destination location and the original directories have been removed. Use show_directory API to confirm the final state matches expectations (zip files present, original directories absent).
[vc-00252] For file system compression tasks: After compressing directories, verify the final state by checking that all target compressed files exist in the destination location and the original directories have been successfully removed. Use show_directory API to confirm the expected directory structure matches the task requirements.
[vc-00254] For recommendation-based filtering tasks with multiple criteria (e.g., genre AND release_date): Verify you first checked if show_recommendations() response contains all needed filtering fields (genre, release_date) before making additional show_song() calls. If the recommendation API provides these fields, filter directly from recommendations to avoid unnecessary API calls. Only call show_song() for songs that pass initial filtering if additional details are needed.
[vc-00257] For recommendation-based playlist creation tasks: Verify you first checked if show_recommendations() response contains genre and release_date fields before making additional show_song() calls. If available, filter recommendations directly to minimize API calls. Verify the final playlist contains all target songs and was created with the correct title and privacy settings.
[vc-00261] For recommendation-based playlist creation tasks: Verify you first checked if show_recommendations() response contains genre and release_date fields before making additional show_song() calls. If available, filter recommendations directly to minimize API calls. Verify the final playlist contains all target songs and was created with the correct title and privacy settings.
[vc-00263] For queue-based like operations: Verify that all target songs (positions <= current_position) are now in the liked songs collection by checking the final liked songs set after the operation. Use proper pagination with show_liked_songs() to ensure complete verification of all target song IDs.
[vc-00266] For bill splitting tasks: Verify you used proper rounding to 2 decimal places for currency amounts and handled any remainder distribution fairly when splitting amounts equally among multiple people. Ensure the calculated share amounts sum back to the original total amount to confirm accuracy.
[vc-00268] For relationship-based contact filtering tasks: Verify you filtered contacts by checking the 'relationships' array contains the target relationship type (e.g., 'roommate') rather than assuming all search results match the criteria. This ensures accurate identification of the target relationships and prevents incorrect calculations based on unfiltered results.
[vc-00272] For alarm modification tasks: Verify the target alarm was moved to the correct new time by checking the time field after update, and verify all other alarms were properly disabled by checking their enabled status. Confirm that only the target alarm remains enabled if the task specifies keeping only one alarm active.
[vc-00273] For playlist duration calculation tasks: Verify you first checked if show_playlist() or show_playlist_library() APIs return duration information directly before making individual show_song() calls. If duration is not available in playlist responses, prefer using show_song_library() and show_liked_songs() APIs to get duration information efficiently rather than individual song calls, as these library APIs provide duration data with significantly fewer API calls.
[vc-00276] For playlist duration calculation tasks requiring minutes conversion: Verify you converted seconds to minutes using proper rounding (round(seconds/60)) to the nearest whole number as specified in the task requirements, rather than using floor division or other rounding methods.
[vc-00280] For playlist-based song metric analysis tasks: Verify you identified the correct user-owned playlist by checking owner email matching (playlist['owner']['email'] == user_email) before proceeding with song analysis, especially when multiple playlists with the same name exist in search results.
[vc-00281] For album-based song selection tasks (e.g., 'most listened to song from [album]'): Verify you searched for the specific album using search_albums API, retrieved all songs from that album using show_album or song_ids from search results, checked the specific metric (play_count, like_count, etc.) for each song using show_song API, identified the song with the maximum value, and played that specific song using play_music with song_id parameter.
[vc-00283] For payment request approval tasks involving specific relationships: Verify you implemented proper pagination for phone contact searches (both roommates and coworkers) to ensure all contacts are retrieved, not just the first page. This ensures complete email matching and prevents missing payment requests from contacts that might be on subsequent pages.
[vc-00284] For payment request approval tasks: After approving all target payment requests, verify completion by checking that no pending requests remain from the specified relationships. Use show_received_payment_requests with status='pending' and filter by sender email matching to confirm all requests were successfully processed.
[vc-00285] For artist unfollowing tasks based on song preferences: Verify you collected all liked songs and followed artists using proper pagination, used set operations to efficiently identify artists not in liked songs, successfully unfollowed all target artists, and confirmed the final following list only contains artists whose songs you have liked.
[vc-00290] For playlist-based song metric analysis tasks (e.g., 'most-liked song in playlists'): Verify you first checked if playlist APIs provide metric information directly before making individual show_song() calls. If individual calls were necessary, verify you implemented caching to avoid duplicate API calls for the same song across multiple playlists, and that you analyzed all songs from all playlists with proper pagination.
[vc-00295] For playlist rating tasks: Verify you collected all liked songs and playlist songs with proper pagination, found the correct intersection of songs that meet both criteria, checked existing reviews using show_song_reviews with user_email filter, and ensured all target songs received 5-star ratings regardless of their previous rating status (creating new reviews or updating existing ones as needed).
[vc-00299] For Venmo transaction filtering tasks involving personal transactions with specific relationships: Verify you used show_transactions() API (not show_social_feed) to access your personal transaction history, filtered by both sent and received directions to capture all transactions involving the specified relationships, and used email matching between transaction parties and contact emails from phone relationships for accurate identification.
[vc-00304] For comprehensive Spotify backup tasks: Verify you collected songs from all specified sources (song library, album library, playlists) using proper pagination with while True loops, combined song IDs using set operations to avoid duplicates, formatted CSV with correct headers and artist separation (using '|' separator), created the file at the specified path with proper content, and terminated the account if requested in the task.
[vc-00312] For 'newest released song' tasks: Verify you collected unique song IDs from all relevant libraries (song library, album library, playlist library) using proper pagination, retrieved song details including release_date for each unique song, and correctly identified the song with the most recent release_date across all sources.
[vc-00314] For 'oldest released song' tasks: Verify you collected unique song IDs from all relevant libraries (song library, album library, playlist library) using proper pagination with while True loops, retrieved song details including release_date for each unique song, and correctly identified the song with the earliest release_date across all sources.
[vc-00318] For 'money received from [relationship] since [date]' tasks: Verify you used phone contacts with relationship queries to identify all target individuals, filtered transactions by direction='received' and date range using dynamic date calculation, implemented proper pagination to collect all transactions, and used email matching between transaction sender emails and contact emails for accurate filtering before summing amounts.
## TROUBLESHOOTING AND PITFALLS:

## OTHERS
[misc-00003] Remember that the email addresses, access tokens and variables (e.g. spotify_password) in the example above are not valid anymore.
[misc-00008] Once you have completed the task, make sure to call apis.supervisor.complete_task(). If the task asked for some information, return it as the answer argument, i.e. call apis.supervisor.complete_task(answer=<answer>). Many tasks do not require an answer, so in those cases, just call apis.supervisor.complete_task() i.e. do not pass any argument.
